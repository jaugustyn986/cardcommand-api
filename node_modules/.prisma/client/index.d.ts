
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>
/**
 * Model Deal
 * 
 */
export type Deal = $Result.DefaultSelection<Prisma.$DealPayload>
/**
 * Model TrackedDeal
 * 
 */
export type TrackedDeal = $Result.DefaultSelection<Prisma.$TrackedDealPayload>
/**
 * Model PortfolioItem
 * 
 */
export type PortfolioItem = $Result.DefaultSelection<Prisma.$PortfolioItemPayload>
/**
 * Model Release
 * 
 */
export type Release = $Result.DefaultSelection<Prisma.$ReleasePayload>
/**
 * Model ReleaseProduct
 * 
 */
export type ReleaseProduct = $Result.DefaultSelection<Prisma.$ReleaseProductPayload>
/**
 * Model ReleaseProductChange
 * 
 */
export type ReleaseProductChange = $Result.DefaultSelection<Prisma.$ReleaseProductChangePayload>
/**
 * Model TrendingItem
 * 
 */
export type TrendingItem = $Result.DefaultSelection<Prisma.$TrendingItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Plan: {
  free: 'free',
  premium: 'premium',
  pro: 'pro'
};

export type Plan = (typeof Plan)[keyof typeof Plan]


export const UserStatus: {
  active: 'active',
  inactive: 'inactive',
  suspended: 'suspended'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const Category: {
  basketball: 'basketball',
  baseball: 'baseball',
  football: 'football',
  hockey: 'hockey',
  soccer: 'soccer',
  pokemon: 'pokemon',
  mtg: 'mtg',
  yugioh: 'yugioh',
  one_piece: 'one_piece',
  digimon: 'digimon',
  lorcana: 'lorcana'
};

export type Category = (typeof Category)[keyof typeof Category]


export const Liquidity: {
  High: 'High',
  Medium: 'Medium',
  Low: 'Low'
};

export type Liquidity = (typeof Liquidity)[keyof typeof Liquidity]


export const SourceTier: {
  A: 'A',
  B: 'B',
  C: 'C'
};

export type SourceTier = (typeof SourceTier)[keyof typeof SourceTier]


export const Confidence: {
  confirmed: 'confirmed',
  unconfirmed: 'unconfirmed',
  rumor: 'rumor'
};

export type Confidence = (typeof Confidence)[keyof typeof Confidence]

}

export type Plan = $Enums.Plan

export const Plan: typeof $Enums.Plan

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type Liquidity = $Enums.Liquidity

export const Liquidity: typeof $Enums.Liquidity

export type SourceTier = $Enums.SourceTier

export const SourceTier: typeof $Enums.SourceTier

export type Confidence = $Enums.Confidence

export const Confidence: typeof $Enums.Confidence

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs>;

  /**
   * `prisma.deal`: Exposes CRUD operations for the **Deal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deals
    * const deals = await prisma.deal.findMany()
    * ```
    */
  get deal(): Prisma.DealDelegate<ExtArgs>;

  /**
   * `prisma.trackedDeal`: Exposes CRUD operations for the **TrackedDeal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrackedDeals
    * const trackedDeals = await prisma.trackedDeal.findMany()
    * ```
    */
  get trackedDeal(): Prisma.TrackedDealDelegate<ExtArgs>;

  /**
   * `prisma.portfolioItem`: Exposes CRUD operations for the **PortfolioItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioItems
    * const portfolioItems = await prisma.portfolioItem.findMany()
    * ```
    */
  get portfolioItem(): Prisma.PortfolioItemDelegate<ExtArgs>;

  /**
   * `prisma.release`: Exposes CRUD operations for the **Release** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Releases
    * const releases = await prisma.release.findMany()
    * ```
    */
  get release(): Prisma.ReleaseDelegate<ExtArgs>;

  /**
   * `prisma.releaseProduct`: Exposes CRUD operations for the **ReleaseProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReleaseProducts
    * const releaseProducts = await prisma.releaseProduct.findMany()
    * ```
    */
  get releaseProduct(): Prisma.ReleaseProductDelegate<ExtArgs>;

  /**
   * `prisma.releaseProductChange`: Exposes CRUD operations for the **ReleaseProductChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReleaseProductChanges
    * const releaseProductChanges = await prisma.releaseProductChange.findMany()
    * ```
    */
  get releaseProductChange(): Prisma.ReleaseProductChangeDelegate<ExtArgs>;

  /**
   * `prisma.trendingItem`: Exposes CRUD operations for the **TrendingItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrendingItems
    * const trendingItems = await prisma.trendingItem.findMany()
    * ```
    */
  get trendingItem(): Prisma.TrendingItemDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserPreferences: 'UserPreferences',
    Deal: 'Deal',
    TrackedDeal: 'TrackedDeal',
    PortfolioItem: 'PortfolioItem',
    Release: 'Release',
    ReleaseProduct: 'ReleaseProduct',
    ReleaseProductChange: 'ReleaseProductChange',
    TrendingItem: 'TrendingItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "userPreferences" | "deal" | "trackedDeal" | "portfolioItem" | "release" | "releaseProduct" | "releaseProductChange" | "trendingItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      Deal: {
        payload: Prisma.$DealPayload<ExtArgs>
        fields: Prisma.DealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findFirst: {
            args: Prisma.DealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findMany: {
            args: Prisma.DealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          create: {
            args: Prisma.DealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          createMany: {
            args: Prisma.DealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          delete: {
            args: Prisma.DealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          update: {
            args: Prisma.DealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          deleteMany: {
            args: Prisma.DealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          aggregate: {
            args: Prisma.DealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeal>
          }
          groupBy: {
            args: Prisma.DealGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealCountArgs<ExtArgs>
            result: $Utils.Optional<DealCountAggregateOutputType> | number
          }
        }
      }
      TrackedDeal: {
        payload: Prisma.$TrackedDealPayload<ExtArgs>
        fields: Prisma.TrackedDealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrackedDealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrackedDealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload>
          }
          findFirst: {
            args: Prisma.TrackedDealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrackedDealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload>
          }
          findMany: {
            args: Prisma.TrackedDealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload>[]
          }
          create: {
            args: Prisma.TrackedDealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload>
          }
          createMany: {
            args: Prisma.TrackedDealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrackedDealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload>[]
          }
          delete: {
            args: Prisma.TrackedDealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload>
          }
          update: {
            args: Prisma.TrackedDealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload>
          }
          deleteMany: {
            args: Prisma.TrackedDealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrackedDealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrackedDealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedDealPayload>
          }
          aggregate: {
            args: Prisma.TrackedDealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrackedDeal>
          }
          groupBy: {
            args: Prisma.TrackedDealGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrackedDealGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrackedDealCountArgs<ExtArgs>
            result: $Utils.Optional<TrackedDealCountAggregateOutputType> | number
          }
        }
      }
      PortfolioItem: {
        payload: Prisma.$PortfolioItemPayload<ExtArgs>
        fields: Prisma.PortfolioItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          findFirst: {
            args: Prisma.PortfolioItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          findMany: {
            args: Prisma.PortfolioItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>[]
          }
          create: {
            args: Prisma.PortfolioItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          createMany: {
            args: Prisma.PortfolioItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>[]
          }
          delete: {
            args: Prisma.PortfolioItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          update: {
            args: Prisma.PortfolioItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PortfolioItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          aggregate: {
            args: Prisma.PortfolioItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioItem>
          }
          groupBy: {
            args: Prisma.PortfolioItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioItemCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioItemCountAggregateOutputType> | number
          }
        }
      }
      Release: {
        payload: Prisma.$ReleasePayload<ExtArgs>
        fields: Prisma.ReleaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReleaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReleaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          findFirst: {
            args: Prisma.ReleaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReleaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          findMany: {
            args: Prisma.ReleaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>[]
          }
          create: {
            args: Prisma.ReleaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          createMany: {
            args: Prisma.ReleaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReleaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>[]
          }
          delete: {
            args: Prisma.ReleaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          update: {
            args: Prisma.ReleaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          deleteMany: {
            args: Prisma.ReleaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReleaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReleaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          aggregate: {
            args: Prisma.ReleaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelease>
          }
          groupBy: {
            args: Prisma.ReleaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReleaseCountArgs<ExtArgs>
            result: $Utils.Optional<ReleaseCountAggregateOutputType> | number
          }
        }
      }
      ReleaseProduct: {
        payload: Prisma.$ReleaseProductPayload<ExtArgs>
        fields: Prisma.ReleaseProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReleaseProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReleaseProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload>
          }
          findFirst: {
            args: Prisma.ReleaseProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReleaseProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload>
          }
          findMany: {
            args: Prisma.ReleaseProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload>[]
          }
          create: {
            args: Prisma.ReleaseProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload>
          }
          createMany: {
            args: Prisma.ReleaseProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReleaseProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload>[]
          }
          delete: {
            args: Prisma.ReleaseProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload>
          }
          update: {
            args: Prisma.ReleaseProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload>
          }
          deleteMany: {
            args: Prisma.ReleaseProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReleaseProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReleaseProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductPayload>
          }
          aggregate: {
            args: Prisma.ReleaseProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReleaseProduct>
          }
          groupBy: {
            args: Prisma.ReleaseProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleaseProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReleaseProductCountArgs<ExtArgs>
            result: $Utils.Optional<ReleaseProductCountAggregateOutputType> | number
          }
        }
      }
      ReleaseProductChange: {
        payload: Prisma.$ReleaseProductChangePayload<ExtArgs>
        fields: Prisma.ReleaseProductChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReleaseProductChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReleaseProductChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload>
          }
          findFirst: {
            args: Prisma.ReleaseProductChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReleaseProductChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload>
          }
          findMany: {
            args: Prisma.ReleaseProductChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload>[]
          }
          create: {
            args: Prisma.ReleaseProductChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload>
          }
          createMany: {
            args: Prisma.ReleaseProductChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReleaseProductChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload>[]
          }
          delete: {
            args: Prisma.ReleaseProductChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload>
          }
          update: {
            args: Prisma.ReleaseProductChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload>
          }
          deleteMany: {
            args: Prisma.ReleaseProductChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReleaseProductChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReleaseProductChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseProductChangePayload>
          }
          aggregate: {
            args: Prisma.ReleaseProductChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReleaseProductChange>
          }
          groupBy: {
            args: Prisma.ReleaseProductChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleaseProductChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReleaseProductChangeCountArgs<ExtArgs>
            result: $Utils.Optional<ReleaseProductChangeCountAggregateOutputType> | number
          }
        }
      }
      TrendingItem: {
        payload: Prisma.$TrendingItemPayload<ExtArgs>
        fields: Prisma.TrendingItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrendingItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrendingItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload>
          }
          findFirst: {
            args: Prisma.TrendingItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrendingItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload>
          }
          findMany: {
            args: Prisma.TrendingItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload>[]
          }
          create: {
            args: Prisma.TrendingItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload>
          }
          createMany: {
            args: Prisma.TrendingItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrendingItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload>[]
          }
          delete: {
            args: Prisma.TrendingItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload>
          }
          update: {
            args: Prisma.TrendingItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload>
          }
          deleteMany: {
            args: Prisma.TrendingItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrendingItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrendingItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingItemPayload>
          }
          aggregate: {
            args: Prisma.TrendingItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrendingItem>
          }
          groupBy: {
            args: Prisma.TrendingItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrendingItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrendingItemCountArgs<ExtArgs>
            result: $Utils.Optional<TrendingItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    portfolio: number
    trackedDeals: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | UserCountOutputTypeCountPortfolioArgs
    trackedDeals?: boolean | UserCountOutputTypeCountTrackedDealsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPortfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrackedDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackedDealWhereInput
  }


  /**
   * Count Type DealCountOutputType
   */

  export type DealCountOutputType = {
    trackedBy: number
  }

  export type DealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trackedBy?: boolean | DealCountOutputTypeCountTrackedByArgs
  }

  // Custom InputTypes
  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealCountOutputType
     */
    select?: DealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountTrackedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackedDealWhereInput
  }


  /**
   * Count Type ReleaseCountOutputType
   */

  export type ReleaseCountOutputType = {
    products: number
  }

  export type ReleaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ReleaseCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ReleaseCountOutputType without action
   */
  export type ReleaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseCountOutputType
     */
    select?: ReleaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReleaseCountOutputType without action
   */
  export type ReleaseCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseProductWhereInput
  }


  /**
   * Count Type ReleaseProductCountOutputType
   */

  export type ReleaseProductCountOutputType = {
    changes: number
  }

  export type ReleaseProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changes?: boolean | ReleaseProductCountOutputTypeCountChangesArgs
  }

  // Custom InputTypes
  /**
   * ReleaseProductCountOutputType without action
   */
  export type ReleaseProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductCountOutputType
     */
    select?: ReleaseProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReleaseProductCountOutputType without action
   */
  export type ReleaseProductCountOutputTypeCountChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseProductChangeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    plan: $Enums.Plan | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    plan: $Enums.Plan | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    plan: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string | null
    plan: $Enums.Plan
    status: $Enums.UserStatus
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    portfolio?: boolean | User$portfolioArgs<ExtArgs>
    trackedDeals?: boolean | User$trackedDealsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    portfolio?: boolean | User$portfolioArgs<ExtArgs>
    trackedDeals?: boolean | User$trackedDealsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      preferences: Prisma.$UserPreferencesPayload<ExtArgs> | null
      portfolio: Prisma.$PortfolioItemPayload<ExtArgs>[]
      trackedDeals: Prisma.$TrackedDealPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string | null
      plan: $Enums.Plan
      status: $Enums.UserStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    portfolio<T extends User$portfolioArgs<ExtArgs> = {}>(args?: Subset<T, User$portfolioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findMany"> | Null>
    trackedDeals<T extends User$trackedDealsArgs<ExtArgs> = {}>(args?: Subset<T, User$trackedDealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly plan: FieldRef<"User", 'Plan'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
  }

  /**
   * User.portfolio
   */
  export type User$portfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    where?: PortfolioItemWhereInput
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    cursor?: PortfolioItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }

  /**
   * User.trackedDeals
   */
  export type User$trackedDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    where?: TrackedDealWhereInput
    orderBy?: TrackedDealOrderByWithRelationInput | TrackedDealOrderByWithRelationInput[]
    cursor?: TrackedDealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackedDealScalarFieldEnum | TrackedDealScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesAvgAggregateOutputType = {
    priceRangeMin: number | null
    priceRangeMax: number | null
    dealAlertThreshold: number | null
  }

  export type UserPreferencesSumAggregateOutputType = {
    priceRangeMin: number | null
    priceRangeMax: number | null
    dealAlertThreshold: number | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    priceRangeMin: number | null
    priceRangeMax: number | null
    dealAlertThreshold: number | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    priceRangeMin: number | null
    priceRangeMax: number | null
    dealAlertThreshold: number | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    categories: number
    priceRangeMin: number
    priceRangeMax: number
    grades: number
    graders: number
    dealAlertThreshold: number
    notificationChannels: number
    _all: number
  }


  export type UserPreferencesAvgAggregateInputType = {
    priceRangeMin?: true
    priceRangeMax?: true
    dealAlertThreshold?: true
  }

  export type UserPreferencesSumAggregateInputType = {
    priceRangeMin?: true
    priceRangeMax?: true
    dealAlertThreshold?: true
  }

  export type UserPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    priceRangeMin?: true
    priceRangeMax?: true
    dealAlertThreshold?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    priceRangeMin?: true
    priceRangeMax?: true
    dealAlertThreshold?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    categories?: true
    priceRangeMin?: true
    priceRangeMax?: true
    grades?: true
    graders?: true
    dealAlertThreshold?: true
    notificationChannels?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _avg?: UserPreferencesAvgAggregateInputType
    _sum?: UserPreferencesSumAggregateInputType
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: string
    userId: string
    categories: string[]
    priceRangeMin: number
    priceRangeMax: number
    grades: string[]
    graders: string[]
    dealAlertThreshold: number
    notificationChannels: string[]
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categories?: boolean
    priceRangeMin?: boolean
    priceRangeMax?: boolean
    grades?: boolean
    graders?: boolean
    dealAlertThreshold?: boolean
    notificationChannels?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categories?: boolean
    priceRangeMin?: boolean
    priceRangeMax?: boolean
    grades?: boolean
    graders?: boolean
    dealAlertThreshold?: boolean
    notificationChannels?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    categories?: boolean
    priceRangeMin?: boolean
    priceRangeMax?: boolean
    grades?: boolean
    graders?: boolean
    dealAlertThreshold?: boolean
    notificationChannels?: boolean
  }

  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      categories: string[]
      priceRangeMin: number
      priceRangeMax: number
      grades: string[]
      graders: string[]
      dealAlertThreshold: number
      notificationChannels: string[]
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */ 
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'String'>
    readonly userId: FieldRef<"UserPreferences", 'String'>
    readonly categories: FieldRef<"UserPreferences", 'String[]'>
    readonly priceRangeMin: FieldRef<"UserPreferences", 'Float'>
    readonly priceRangeMax: FieldRef<"UserPreferences", 'Float'>
    readonly grades: FieldRef<"UserPreferences", 'String[]'>
    readonly graders: FieldRef<"UserPreferences", 'String[]'>
    readonly dealAlertThreshold: FieldRef<"UserPreferences", 'Float'>
    readonly notificationChannels: FieldRef<"UserPreferences", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model Deal
   */

  export type AggregateDeal = {
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  export type DealAvgAggregateOutputType = {
    year: number | null
    marketPrice: number | null
    dealPrice: number | null
    savingsPercent: number | null
    savingsAmount: number | null
    sellerRating: number | null
    sellerFeedback: number | null
    lastSoldPrice: number | null
    thirtyDayAvg: number | null
    ninetyDayTrend: number | null
    popGraded: number | null
    popGrade10: number | null
  }

  export type DealSumAggregateOutputType = {
    year: number | null
    marketPrice: number | null
    dealPrice: number | null
    savingsPercent: number | null
    savingsAmount: number | null
    sellerRating: number | null
    sellerFeedback: number | null
    lastSoldPrice: number | null
    thirtyDayAvg: number | null
    ninetyDayTrend: number | null
    popGraded: number | null
    popGrade10: number | null
  }

  export type DealMinAggregateOutputType = {
    id: string | null
    cardName: string | null
    cardSet: string | null
    year: number | null
    cardNumber: string | null
    variation: string | null
    grade: string | null
    grader: string | null
    marketPrice: number | null
    dealPrice: number | null
    savingsPercent: number | null
    savingsAmount: number | null
    marketplace: string | null
    sellerRating: number | null
    sellerFeedback: number | null
    listingUrl: string | null
    imageUrl: string | null
    category: $Enums.Category | null
    liquidity: $Enums.Liquidity | null
    lastSoldPrice: number | null
    thirtyDayAvg: number | null
    ninetyDayTrend: number | null
    popGraded: number | null
    popGrade10: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealMaxAggregateOutputType = {
    id: string | null
    cardName: string | null
    cardSet: string | null
    year: number | null
    cardNumber: string | null
    variation: string | null
    grade: string | null
    grader: string | null
    marketPrice: number | null
    dealPrice: number | null
    savingsPercent: number | null
    savingsAmount: number | null
    marketplace: string | null
    sellerRating: number | null
    sellerFeedback: number | null
    listingUrl: string | null
    imageUrl: string | null
    category: $Enums.Category | null
    liquidity: $Enums.Liquidity | null
    lastSoldPrice: number | null
    thirtyDayAvg: number | null
    ninetyDayTrend: number | null
    popGraded: number | null
    popGrade10: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealCountAggregateOutputType = {
    id: number
    cardName: number
    cardSet: number
    year: number
    cardNumber: number
    variation: number
    grade: number
    grader: number
    marketPrice: number
    dealPrice: number
    savingsPercent: number
    savingsAmount: number
    marketplace: number
    sellerRating: number
    sellerFeedback: number
    listingUrl: number
    imageUrl: number
    category: number
    liquidity: number
    lastSoldPrice: number
    thirtyDayAvg: number
    ninetyDayTrend: number
    popGraded: number
    popGrade10: number
    isActive: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    strategy: number
    _all: number
  }


  export type DealAvgAggregateInputType = {
    year?: true
    marketPrice?: true
    dealPrice?: true
    savingsPercent?: true
    savingsAmount?: true
    sellerRating?: true
    sellerFeedback?: true
    lastSoldPrice?: true
    thirtyDayAvg?: true
    ninetyDayTrend?: true
    popGraded?: true
    popGrade10?: true
  }

  export type DealSumAggregateInputType = {
    year?: true
    marketPrice?: true
    dealPrice?: true
    savingsPercent?: true
    savingsAmount?: true
    sellerRating?: true
    sellerFeedback?: true
    lastSoldPrice?: true
    thirtyDayAvg?: true
    ninetyDayTrend?: true
    popGraded?: true
    popGrade10?: true
  }

  export type DealMinAggregateInputType = {
    id?: true
    cardName?: true
    cardSet?: true
    year?: true
    cardNumber?: true
    variation?: true
    grade?: true
    grader?: true
    marketPrice?: true
    dealPrice?: true
    savingsPercent?: true
    savingsAmount?: true
    marketplace?: true
    sellerRating?: true
    sellerFeedback?: true
    listingUrl?: true
    imageUrl?: true
    category?: true
    liquidity?: true
    lastSoldPrice?: true
    thirtyDayAvg?: true
    ninetyDayTrend?: true
    popGraded?: true
    popGrade10?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealMaxAggregateInputType = {
    id?: true
    cardName?: true
    cardSet?: true
    year?: true
    cardNumber?: true
    variation?: true
    grade?: true
    grader?: true
    marketPrice?: true
    dealPrice?: true
    savingsPercent?: true
    savingsAmount?: true
    marketplace?: true
    sellerRating?: true
    sellerFeedback?: true
    listingUrl?: true
    imageUrl?: true
    category?: true
    liquidity?: true
    lastSoldPrice?: true
    thirtyDayAvg?: true
    ninetyDayTrend?: true
    popGraded?: true
    popGrade10?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealCountAggregateInputType = {
    id?: true
    cardName?: true
    cardSet?: true
    year?: true
    cardNumber?: true
    variation?: true
    grade?: true
    grader?: true
    marketPrice?: true
    dealPrice?: true
    savingsPercent?: true
    savingsAmount?: true
    marketplace?: true
    sellerRating?: true
    sellerFeedback?: true
    listingUrl?: true
    imageUrl?: true
    category?: true
    liquidity?: true
    lastSoldPrice?: true
    thirtyDayAvg?: true
    ninetyDayTrend?: true
    popGraded?: true
    popGrade10?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    strategy?: true
    _all?: true
  }

  export type DealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deal to aggregate.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deals
    **/
    _count?: true | DealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMaxAggregateInputType
  }

  export type GetDealAggregateType<T extends DealAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal[P]>
      : GetScalarType<T[P], AggregateDeal[P]>
  }




  export type DealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
    orderBy?: DealOrderByWithAggregationInput | DealOrderByWithAggregationInput[]
    by: DealScalarFieldEnum[] | DealScalarFieldEnum
    having?: DealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealCountAggregateInputType | true
    _avg?: DealAvgAggregateInputType
    _sum?: DealSumAggregateInputType
    _min?: DealMinAggregateInputType
    _max?: DealMaxAggregateInputType
  }

  export type DealGroupByOutputType = {
    id: string
    cardName: string
    cardSet: string
    year: number
    cardNumber: string | null
    variation: string | null
    grade: string
    grader: string | null
    marketPrice: number
    dealPrice: number
    savingsPercent: number
    savingsAmount: number
    marketplace: string
    sellerRating: number
    sellerFeedback: number
    listingUrl: string
    imageUrl: string | null
    category: $Enums.Category
    liquidity: $Enums.Liquidity
    lastSoldPrice: number | null
    thirtyDayAvg: number | null
    ninetyDayTrend: number | null
    popGraded: number | null
    popGrade10: number | null
    isActive: boolean
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    strategy: JsonValue | null
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  type GetDealGroupByPayload<T extends DealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealGroupByOutputType[P]>
            : GetScalarType<T[P], DealGroupByOutputType[P]>
        }
      >
    >


  export type DealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardName?: boolean
    cardSet?: boolean
    year?: boolean
    cardNumber?: boolean
    variation?: boolean
    grade?: boolean
    grader?: boolean
    marketPrice?: boolean
    dealPrice?: boolean
    savingsPercent?: boolean
    savingsAmount?: boolean
    marketplace?: boolean
    sellerRating?: boolean
    sellerFeedback?: boolean
    listingUrl?: boolean
    imageUrl?: boolean
    category?: boolean
    liquidity?: boolean
    lastSoldPrice?: boolean
    thirtyDayAvg?: boolean
    ninetyDayTrend?: boolean
    popGraded?: boolean
    popGrade10?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean
    trackedBy?: boolean | Deal$trackedByArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardName?: boolean
    cardSet?: boolean
    year?: boolean
    cardNumber?: boolean
    variation?: boolean
    grade?: boolean
    grader?: boolean
    marketPrice?: boolean
    dealPrice?: boolean
    savingsPercent?: boolean
    savingsAmount?: boolean
    marketplace?: boolean
    sellerRating?: boolean
    sellerFeedback?: boolean
    listingUrl?: boolean
    imageUrl?: boolean
    category?: boolean
    liquidity?: boolean
    lastSoldPrice?: boolean
    thirtyDayAvg?: boolean
    ninetyDayTrend?: boolean
    popGraded?: boolean
    popGrade10?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean
  }, ExtArgs["result"]["deal"]>

  export type DealSelectScalar = {
    id?: boolean
    cardName?: boolean
    cardSet?: boolean
    year?: boolean
    cardNumber?: boolean
    variation?: boolean
    grade?: boolean
    grader?: boolean
    marketPrice?: boolean
    dealPrice?: boolean
    savingsPercent?: boolean
    savingsAmount?: boolean
    marketplace?: boolean
    sellerRating?: boolean
    sellerFeedback?: boolean
    listingUrl?: boolean
    imageUrl?: boolean
    category?: boolean
    liquidity?: boolean
    lastSoldPrice?: boolean
    thirtyDayAvg?: boolean
    ninetyDayTrend?: boolean
    popGraded?: boolean
    popGrade10?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean
  }

  export type DealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trackedBy?: boolean | Deal$trackedByArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deal"
    objects: {
      trackedBy: Prisma.$TrackedDealPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cardName: string
      cardSet: string
      year: number
      cardNumber: string | null
      variation: string | null
      grade: string
      grader: string | null
      marketPrice: number
      dealPrice: number
      savingsPercent: number
      savingsAmount: number
      marketplace: string
      sellerRating: number
      sellerFeedback: number
      listingUrl: string
      imageUrl: string | null
      category: $Enums.Category
      liquidity: $Enums.Liquidity
      lastSoldPrice: number | null
      thirtyDayAvg: number | null
      ninetyDayTrend: number | null
      popGraded: number | null
      popGrade10: number | null
      isActive: boolean
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      strategy: Prisma.JsonValue | null
    }, ExtArgs["result"]["deal"]>
    composites: {}
  }

  type DealGetPayload<S extends boolean | null | undefined | DealDefaultArgs> = $Result.GetResult<Prisma.$DealPayload, S>

  type DealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DealCountAggregateInputType | true
    }

  export interface DealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deal'], meta: { name: 'Deal' } }
    /**
     * Find zero or one Deal that matches the filter.
     * @param {DealFindUniqueArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealFindUniqueArgs>(args: SelectSubset<T, DealFindUniqueArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DealFindUniqueOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealFindUniqueOrThrowArgs>(args: SelectSubset<T, DealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealFindFirstArgs>(args?: SelectSubset<T, DealFindFirstArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealFindFirstOrThrowArgs>(args?: SelectSubset<T, DealFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deals
     * const deals = await prisma.deal.findMany()
     * 
     * // Get first 10 Deals
     * const deals = await prisma.deal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealWithIdOnly = await prisma.deal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealFindManyArgs>(args?: SelectSubset<T, DealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deal.
     * @param {DealCreateArgs} args - Arguments to create a Deal.
     * @example
     * // Create one Deal
     * const Deal = await prisma.deal.create({
     *   data: {
     *     // ... data to create a Deal
     *   }
     * })
     * 
     */
    create<T extends DealCreateArgs>(args: SelectSubset<T, DealCreateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deals.
     * @param {DealCreateManyArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealCreateManyArgs>(args?: SelectSubset<T, DealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deals and returns the data saved in the database.
     * @param {DealCreateManyAndReturnArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deals and only return the `id`
     * const dealWithIdOnly = await prisma.deal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealCreateManyAndReturnArgs>(args?: SelectSubset<T, DealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Deal.
     * @param {DealDeleteArgs} args - Arguments to delete one Deal.
     * @example
     * // Delete one Deal
     * const Deal = await prisma.deal.delete({
     *   where: {
     *     // ... filter to delete one Deal
     *   }
     * })
     * 
     */
    delete<T extends DealDeleteArgs>(args: SelectSubset<T, DealDeleteArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deal.
     * @param {DealUpdateArgs} args - Arguments to update one Deal.
     * @example
     * // Update one Deal
     * const deal = await prisma.deal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealUpdateArgs>(args: SelectSubset<T, DealUpdateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deals.
     * @param {DealDeleteManyArgs} args - Arguments to filter Deals to delete.
     * @example
     * // Delete a few Deals
     * const { count } = await prisma.deal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealDeleteManyArgs>(args?: SelectSubset<T, DealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealUpdateManyArgs>(args: SelectSubset<T, DealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deal.
     * @param {DealUpsertArgs} args - Arguments to update or create a Deal.
     * @example
     * // Update or create a Deal
     * const deal = await prisma.deal.upsert({
     *   create: {
     *     // ... data to create a Deal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal we want to update
     *   }
     * })
     */
    upsert<T extends DealUpsertArgs>(args: SelectSubset<T, DealUpsertArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealCountArgs} args - Arguments to filter Deals to count.
     * @example
     * // Count the number of Deals
     * const count = await prisma.deal.count({
     *   where: {
     *     // ... the filter for the Deals we want to count
     *   }
     * })
    **/
    count<T extends DealCountArgs>(
      args?: Subset<T, DealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealAggregateArgs>(args: Subset<T, DealAggregateArgs>): Prisma.PrismaPromise<GetDealAggregateType<T>>

    /**
     * Group by Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealGroupByArgs['orderBy'] }
        : { orderBy?: DealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deal model
   */
  readonly fields: DealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trackedBy<T extends Deal$trackedByArgs<ExtArgs> = {}>(args?: Subset<T, Deal$trackedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deal model
   */ 
  interface DealFieldRefs {
    readonly id: FieldRef<"Deal", 'String'>
    readonly cardName: FieldRef<"Deal", 'String'>
    readonly cardSet: FieldRef<"Deal", 'String'>
    readonly year: FieldRef<"Deal", 'Int'>
    readonly cardNumber: FieldRef<"Deal", 'String'>
    readonly variation: FieldRef<"Deal", 'String'>
    readonly grade: FieldRef<"Deal", 'String'>
    readonly grader: FieldRef<"Deal", 'String'>
    readonly marketPrice: FieldRef<"Deal", 'Float'>
    readonly dealPrice: FieldRef<"Deal", 'Float'>
    readonly savingsPercent: FieldRef<"Deal", 'Float'>
    readonly savingsAmount: FieldRef<"Deal", 'Float'>
    readonly marketplace: FieldRef<"Deal", 'String'>
    readonly sellerRating: FieldRef<"Deal", 'Float'>
    readonly sellerFeedback: FieldRef<"Deal", 'Int'>
    readonly listingUrl: FieldRef<"Deal", 'String'>
    readonly imageUrl: FieldRef<"Deal", 'String'>
    readonly category: FieldRef<"Deal", 'Category'>
    readonly liquidity: FieldRef<"Deal", 'Liquidity'>
    readonly lastSoldPrice: FieldRef<"Deal", 'Float'>
    readonly thirtyDayAvg: FieldRef<"Deal", 'Float'>
    readonly ninetyDayTrend: FieldRef<"Deal", 'Float'>
    readonly popGraded: FieldRef<"Deal", 'Int'>
    readonly popGrade10: FieldRef<"Deal", 'Int'>
    readonly isActive: FieldRef<"Deal", 'Boolean'>
    readonly expiresAt: FieldRef<"Deal", 'DateTime'>
    readonly createdAt: FieldRef<"Deal", 'DateTime'>
    readonly updatedAt: FieldRef<"Deal", 'DateTime'>
    readonly strategy: FieldRef<"Deal", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Deal findUnique
   */
  export type DealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findUniqueOrThrow
   */
  export type DealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findFirst
   */
  export type DealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findFirstOrThrow
   */
  export type DealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findMany
   */
  export type DealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deals to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal create
   */
  export type DealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to create a Deal.
     */
    data: XOR<DealCreateInput, DealUncheckedCreateInput>
  }

  /**
   * Deal createMany
   */
  export type DealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deal createManyAndReturn
   */
  export type DealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deal update
   */
  export type DealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to update a Deal.
     */
    data: XOR<DealUpdateInput, DealUncheckedUpdateInput>
    /**
     * Choose, which Deal to update.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal updateMany
   */
  export type DealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
  }

  /**
   * Deal upsert
   */
  export type DealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The filter to search for the Deal to update in case it exists.
     */
    where: DealWhereUniqueInput
    /**
     * In case the Deal found by the `where` argument doesn't exist, create a new Deal with this data.
     */
    create: XOR<DealCreateInput, DealUncheckedCreateInput>
    /**
     * In case the Deal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealUpdateInput, DealUncheckedUpdateInput>
  }

  /**
   * Deal delete
   */
  export type DealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter which Deal to delete.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal deleteMany
   */
  export type DealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deals to delete
     */
    where?: DealWhereInput
  }

  /**
   * Deal.trackedBy
   */
  export type Deal$trackedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    where?: TrackedDealWhereInput
    orderBy?: TrackedDealOrderByWithRelationInput | TrackedDealOrderByWithRelationInput[]
    cursor?: TrackedDealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackedDealScalarFieldEnum | TrackedDealScalarFieldEnum[]
  }

  /**
   * Deal without action
   */
  export type DealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
  }


  /**
   * Model TrackedDeal
   */

  export type AggregateTrackedDeal = {
    _count: TrackedDealCountAggregateOutputType | null
    _min: TrackedDealMinAggregateOutputType | null
    _max: TrackedDealMaxAggregateOutputType | null
  }

  export type TrackedDealMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    createdAt: Date | null
  }

  export type TrackedDealMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    createdAt: Date | null
  }

  export type TrackedDealCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    createdAt: number
    _all: number
  }


  export type TrackedDealMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    createdAt?: true
  }

  export type TrackedDealMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    createdAt?: true
  }

  export type TrackedDealCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    createdAt?: true
    _all?: true
  }

  export type TrackedDealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackedDeal to aggregate.
     */
    where?: TrackedDealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackedDeals to fetch.
     */
    orderBy?: TrackedDealOrderByWithRelationInput | TrackedDealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrackedDealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackedDeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackedDeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrackedDeals
    **/
    _count?: true | TrackedDealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackedDealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackedDealMaxAggregateInputType
  }

  export type GetTrackedDealAggregateType<T extends TrackedDealAggregateArgs> = {
        [P in keyof T & keyof AggregateTrackedDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrackedDeal[P]>
      : GetScalarType<T[P], AggregateTrackedDeal[P]>
  }




  export type TrackedDealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackedDealWhereInput
    orderBy?: TrackedDealOrderByWithAggregationInput | TrackedDealOrderByWithAggregationInput[]
    by: TrackedDealScalarFieldEnum[] | TrackedDealScalarFieldEnum
    having?: TrackedDealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackedDealCountAggregateInputType | true
    _min?: TrackedDealMinAggregateInputType
    _max?: TrackedDealMaxAggregateInputType
  }

  export type TrackedDealGroupByOutputType = {
    id: string
    userId: string
    dealId: string
    createdAt: Date
    _count: TrackedDealCountAggregateOutputType | null
    _min: TrackedDealMinAggregateOutputType | null
    _max: TrackedDealMaxAggregateOutputType | null
  }

  type GetTrackedDealGroupByPayload<T extends TrackedDealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackedDealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackedDealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackedDealGroupByOutputType[P]>
            : GetScalarType<T[P], TrackedDealGroupByOutputType[P]>
        }
      >
    >


  export type TrackedDealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | DealDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackedDeal"]>

  export type TrackedDealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | DealDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackedDeal"]>

  export type TrackedDealSelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    createdAt?: boolean
  }

  export type TrackedDealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | DealDefaultArgs<ExtArgs>
  }
  export type TrackedDealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | DealDefaultArgs<ExtArgs>
  }

  export type $TrackedDealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrackedDeal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string
      createdAt: Date
    }, ExtArgs["result"]["trackedDeal"]>
    composites: {}
  }

  type TrackedDealGetPayload<S extends boolean | null | undefined | TrackedDealDefaultArgs> = $Result.GetResult<Prisma.$TrackedDealPayload, S>

  type TrackedDealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrackedDealFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrackedDealCountAggregateInputType | true
    }

  export interface TrackedDealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrackedDeal'], meta: { name: 'TrackedDeal' } }
    /**
     * Find zero or one TrackedDeal that matches the filter.
     * @param {TrackedDealFindUniqueArgs} args - Arguments to find a TrackedDeal
     * @example
     * // Get one TrackedDeal
     * const trackedDeal = await prisma.trackedDeal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrackedDealFindUniqueArgs>(args: SelectSubset<T, TrackedDealFindUniqueArgs<ExtArgs>>): Prisma__TrackedDealClient<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrackedDeal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrackedDealFindUniqueOrThrowArgs} args - Arguments to find a TrackedDeal
     * @example
     * // Get one TrackedDeal
     * const trackedDeal = await prisma.trackedDeal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrackedDealFindUniqueOrThrowArgs>(args: SelectSubset<T, TrackedDealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrackedDealClient<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrackedDeal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedDealFindFirstArgs} args - Arguments to find a TrackedDeal
     * @example
     * // Get one TrackedDeal
     * const trackedDeal = await prisma.trackedDeal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrackedDealFindFirstArgs>(args?: SelectSubset<T, TrackedDealFindFirstArgs<ExtArgs>>): Prisma__TrackedDealClient<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrackedDeal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedDealFindFirstOrThrowArgs} args - Arguments to find a TrackedDeal
     * @example
     * // Get one TrackedDeal
     * const trackedDeal = await prisma.trackedDeal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrackedDealFindFirstOrThrowArgs>(args?: SelectSubset<T, TrackedDealFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrackedDealClient<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrackedDeals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedDealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrackedDeals
     * const trackedDeals = await prisma.trackedDeal.findMany()
     * 
     * // Get first 10 TrackedDeals
     * const trackedDeals = await prisma.trackedDeal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trackedDealWithIdOnly = await prisma.trackedDeal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrackedDealFindManyArgs>(args?: SelectSubset<T, TrackedDealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrackedDeal.
     * @param {TrackedDealCreateArgs} args - Arguments to create a TrackedDeal.
     * @example
     * // Create one TrackedDeal
     * const TrackedDeal = await prisma.trackedDeal.create({
     *   data: {
     *     // ... data to create a TrackedDeal
     *   }
     * })
     * 
     */
    create<T extends TrackedDealCreateArgs>(args: SelectSubset<T, TrackedDealCreateArgs<ExtArgs>>): Prisma__TrackedDealClient<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrackedDeals.
     * @param {TrackedDealCreateManyArgs} args - Arguments to create many TrackedDeals.
     * @example
     * // Create many TrackedDeals
     * const trackedDeal = await prisma.trackedDeal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrackedDealCreateManyArgs>(args?: SelectSubset<T, TrackedDealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrackedDeals and returns the data saved in the database.
     * @param {TrackedDealCreateManyAndReturnArgs} args - Arguments to create many TrackedDeals.
     * @example
     * // Create many TrackedDeals
     * const trackedDeal = await prisma.trackedDeal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrackedDeals and only return the `id`
     * const trackedDealWithIdOnly = await prisma.trackedDeal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrackedDealCreateManyAndReturnArgs>(args?: SelectSubset<T, TrackedDealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrackedDeal.
     * @param {TrackedDealDeleteArgs} args - Arguments to delete one TrackedDeal.
     * @example
     * // Delete one TrackedDeal
     * const TrackedDeal = await prisma.trackedDeal.delete({
     *   where: {
     *     // ... filter to delete one TrackedDeal
     *   }
     * })
     * 
     */
    delete<T extends TrackedDealDeleteArgs>(args: SelectSubset<T, TrackedDealDeleteArgs<ExtArgs>>): Prisma__TrackedDealClient<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrackedDeal.
     * @param {TrackedDealUpdateArgs} args - Arguments to update one TrackedDeal.
     * @example
     * // Update one TrackedDeal
     * const trackedDeal = await prisma.trackedDeal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrackedDealUpdateArgs>(args: SelectSubset<T, TrackedDealUpdateArgs<ExtArgs>>): Prisma__TrackedDealClient<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrackedDeals.
     * @param {TrackedDealDeleteManyArgs} args - Arguments to filter TrackedDeals to delete.
     * @example
     * // Delete a few TrackedDeals
     * const { count } = await prisma.trackedDeal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrackedDealDeleteManyArgs>(args?: SelectSubset<T, TrackedDealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrackedDeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedDealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrackedDeals
     * const trackedDeal = await prisma.trackedDeal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrackedDealUpdateManyArgs>(args: SelectSubset<T, TrackedDealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrackedDeal.
     * @param {TrackedDealUpsertArgs} args - Arguments to update or create a TrackedDeal.
     * @example
     * // Update or create a TrackedDeal
     * const trackedDeal = await prisma.trackedDeal.upsert({
     *   create: {
     *     // ... data to create a TrackedDeal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrackedDeal we want to update
     *   }
     * })
     */
    upsert<T extends TrackedDealUpsertArgs>(args: SelectSubset<T, TrackedDealUpsertArgs<ExtArgs>>): Prisma__TrackedDealClient<$Result.GetResult<Prisma.$TrackedDealPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrackedDeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedDealCountArgs} args - Arguments to filter TrackedDeals to count.
     * @example
     * // Count the number of TrackedDeals
     * const count = await prisma.trackedDeal.count({
     *   where: {
     *     // ... the filter for the TrackedDeals we want to count
     *   }
     * })
    **/
    count<T extends TrackedDealCountArgs>(
      args?: Subset<T, TrackedDealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackedDealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrackedDeal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedDealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackedDealAggregateArgs>(args: Subset<T, TrackedDealAggregateArgs>): Prisma.PrismaPromise<GetTrackedDealAggregateType<T>>

    /**
     * Group by TrackedDeal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedDealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrackedDealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrackedDealGroupByArgs['orderBy'] }
        : { orderBy?: TrackedDealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrackedDealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackedDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrackedDeal model
   */
  readonly fields: TrackedDealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrackedDeal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrackedDealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deal<T extends DealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DealDefaultArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrackedDeal model
   */ 
  interface TrackedDealFieldRefs {
    readonly id: FieldRef<"TrackedDeal", 'String'>
    readonly userId: FieldRef<"TrackedDeal", 'String'>
    readonly dealId: FieldRef<"TrackedDeal", 'String'>
    readonly createdAt: FieldRef<"TrackedDeal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrackedDeal findUnique
   */
  export type TrackedDealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    /**
     * Filter, which TrackedDeal to fetch.
     */
    where: TrackedDealWhereUniqueInput
  }

  /**
   * TrackedDeal findUniqueOrThrow
   */
  export type TrackedDealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    /**
     * Filter, which TrackedDeal to fetch.
     */
    where: TrackedDealWhereUniqueInput
  }

  /**
   * TrackedDeal findFirst
   */
  export type TrackedDealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    /**
     * Filter, which TrackedDeal to fetch.
     */
    where?: TrackedDealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackedDeals to fetch.
     */
    orderBy?: TrackedDealOrderByWithRelationInput | TrackedDealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackedDeals.
     */
    cursor?: TrackedDealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackedDeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackedDeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackedDeals.
     */
    distinct?: TrackedDealScalarFieldEnum | TrackedDealScalarFieldEnum[]
  }

  /**
   * TrackedDeal findFirstOrThrow
   */
  export type TrackedDealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    /**
     * Filter, which TrackedDeal to fetch.
     */
    where?: TrackedDealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackedDeals to fetch.
     */
    orderBy?: TrackedDealOrderByWithRelationInput | TrackedDealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackedDeals.
     */
    cursor?: TrackedDealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackedDeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackedDeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackedDeals.
     */
    distinct?: TrackedDealScalarFieldEnum | TrackedDealScalarFieldEnum[]
  }

  /**
   * TrackedDeal findMany
   */
  export type TrackedDealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    /**
     * Filter, which TrackedDeals to fetch.
     */
    where?: TrackedDealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackedDeals to fetch.
     */
    orderBy?: TrackedDealOrderByWithRelationInput | TrackedDealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrackedDeals.
     */
    cursor?: TrackedDealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackedDeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackedDeals.
     */
    skip?: number
    distinct?: TrackedDealScalarFieldEnum | TrackedDealScalarFieldEnum[]
  }

  /**
   * TrackedDeal create
   */
  export type TrackedDealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    /**
     * The data needed to create a TrackedDeal.
     */
    data: XOR<TrackedDealCreateInput, TrackedDealUncheckedCreateInput>
  }

  /**
   * TrackedDeal createMany
   */
  export type TrackedDealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrackedDeals.
     */
    data: TrackedDealCreateManyInput | TrackedDealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrackedDeal createManyAndReturn
   */
  export type TrackedDealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrackedDeals.
     */
    data: TrackedDealCreateManyInput | TrackedDealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrackedDeal update
   */
  export type TrackedDealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    /**
     * The data needed to update a TrackedDeal.
     */
    data: XOR<TrackedDealUpdateInput, TrackedDealUncheckedUpdateInput>
    /**
     * Choose, which TrackedDeal to update.
     */
    where: TrackedDealWhereUniqueInput
  }

  /**
   * TrackedDeal updateMany
   */
  export type TrackedDealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrackedDeals.
     */
    data: XOR<TrackedDealUpdateManyMutationInput, TrackedDealUncheckedUpdateManyInput>
    /**
     * Filter which TrackedDeals to update
     */
    where?: TrackedDealWhereInput
  }

  /**
   * TrackedDeal upsert
   */
  export type TrackedDealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    /**
     * The filter to search for the TrackedDeal to update in case it exists.
     */
    where: TrackedDealWhereUniqueInput
    /**
     * In case the TrackedDeal found by the `where` argument doesn't exist, create a new TrackedDeal with this data.
     */
    create: XOR<TrackedDealCreateInput, TrackedDealUncheckedCreateInput>
    /**
     * In case the TrackedDeal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrackedDealUpdateInput, TrackedDealUncheckedUpdateInput>
  }

  /**
   * TrackedDeal delete
   */
  export type TrackedDealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
    /**
     * Filter which TrackedDeal to delete.
     */
    where: TrackedDealWhereUniqueInput
  }

  /**
   * TrackedDeal deleteMany
   */
  export type TrackedDealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackedDeals to delete
     */
    where?: TrackedDealWhereInput
  }

  /**
   * TrackedDeal without action
   */
  export type TrackedDealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedDeal
     */
    select?: TrackedDealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedDealInclude<ExtArgs> | null
  }


  /**
   * Model PortfolioItem
   */

  export type AggregatePortfolioItem = {
    _count: PortfolioItemCountAggregateOutputType | null
    _avg: PortfolioItemAvgAggregateOutputType | null
    _sum: PortfolioItemSumAggregateOutputType | null
    _min: PortfolioItemMinAggregateOutputType | null
    _max: PortfolioItemMaxAggregateOutputType | null
  }

  export type PortfolioItemAvgAggregateOutputType = {
    year: number | null
    currentValue: number | null
    purchasePrice: number | null
    quantity: number | null
  }

  export type PortfolioItemSumAggregateOutputType = {
    year: number | null
    currentValue: number | null
    purchasePrice: number | null
    quantity: number | null
  }

  export type PortfolioItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cardName: string | null
    cardSet: string | null
    year: number | null
    grade: string | null
    grader: string | null
    currentValue: number | null
    purchasePrice: number | null
    purchaseDate: Date | null
    quantity: number | null
    imageUrl: string | null
    notes: string | null
    inGradingQueue: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cardName: string | null
    cardSet: string | null
    year: number | null
    grade: string | null
    grader: string | null
    currentValue: number | null
    purchasePrice: number | null
    purchaseDate: Date | null
    quantity: number | null
    imageUrl: string | null
    notes: string | null
    inGradingQueue: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioItemCountAggregateOutputType = {
    id: number
    userId: number
    cardName: number
    cardSet: number
    year: number
    grade: number
    grader: number
    currentValue: number
    purchasePrice: number
    purchaseDate: number
    quantity: number
    imageUrl: number
    notes: number
    inGradingQueue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioItemAvgAggregateInputType = {
    year?: true
    currentValue?: true
    purchasePrice?: true
    quantity?: true
  }

  export type PortfolioItemSumAggregateInputType = {
    year?: true
    currentValue?: true
    purchasePrice?: true
    quantity?: true
  }

  export type PortfolioItemMinAggregateInputType = {
    id?: true
    userId?: true
    cardName?: true
    cardSet?: true
    year?: true
    grade?: true
    grader?: true
    currentValue?: true
    purchasePrice?: true
    purchaseDate?: true
    quantity?: true
    imageUrl?: true
    notes?: true
    inGradingQueue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioItemMaxAggregateInputType = {
    id?: true
    userId?: true
    cardName?: true
    cardSet?: true
    year?: true
    grade?: true
    grader?: true
    currentValue?: true
    purchasePrice?: true
    purchaseDate?: true
    quantity?: true
    imageUrl?: true
    notes?: true
    inGradingQueue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioItemCountAggregateInputType = {
    id?: true
    userId?: true
    cardName?: true
    cardSet?: true
    year?: true
    grade?: true
    grader?: true
    currentValue?: true
    purchasePrice?: true
    purchaseDate?: true
    quantity?: true
    imageUrl?: true
    notes?: true
    inGradingQueue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioItem to aggregate.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioItems
    **/
    _count?: true | PortfolioItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortfolioItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortfolioItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioItemMaxAggregateInputType
  }

  export type GetPortfolioItemAggregateType<T extends PortfolioItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioItem[P]>
      : GetScalarType<T[P], AggregatePortfolioItem[P]>
  }




  export type PortfolioItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioItemWhereInput
    orderBy?: PortfolioItemOrderByWithAggregationInput | PortfolioItemOrderByWithAggregationInput[]
    by: PortfolioItemScalarFieldEnum[] | PortfolioItemScalarFieldEnum
    having?: PortfolioItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioItemCountAggregateInputType | true
    _avg?: PortfolioItemAvgAggregateInputType
    _sum?: PortfolioItemSumAggregateInputType
    _min?: PortfolioItemMinAggregateInputType
    _max?: PortfolioItemMaxAggregateInputType
  }

  export type PortfolioItemGroupByOutputType = {
    id: string
    userId: string
    cardName: string
    cardSet: string
    year: number
    grade: string
    grader: string | null
    currentValue: number
    purchasePrice: number
    purchaseDate: Date
    quantity: number
    imageUrl: string | null
    notes: string | null
    inGradingQueue: boolean
    createdAt: Date
    updatedAt: Date
    _count: PortfolioItemCountAggregateOutputType | null
    _avg: PortfolioItemAvgAggregateOutputType | null
    _sum: PortfolioItemSumAggregateOutputType | null
    _min: PortfolioItemMinAggregateOutputType | null
    _max: PortfolioItemMaxAggregateOutputType | null
  }

  type GetPortfolioItemGroupByPayload<T extends PortfolioItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioItemGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioItemGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardName?: boolean
    cardSet?: boolean
    year?: boolean
    grade?: boolean
    grader?: boolean
    currentValue?: boolean
    purchasePrice?: boolean
    purchaseDate?: boolean
    quantity?: boolean
    imageUrl?: boolean
    notes?: boolean
    inGradingQueue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioItem"]>

  export type PortfolioItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardName?: boolean
    cardSet?: boolean
    year?: boolean
    grade?: boolean
    grader?: boolean
    currentValue?: boolean
    purchasePrice?: boolean
    purchaseDate?: boolean
    quantity?: boolean
    imageUrl?: boolean
    notes?: boolean
    inGradingQueue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioItem"]>

  export type PortfolioItemSelectScalar = {
    id?: boolean
    userId?: boolean
    cardName?: boolean
    cardSet?: boolean
    year?: boolean
    grade?: boolean
    grader?: boolean
    currentValue?: boolean
    purchasePrice?: boolean
    purchaseDate?: boolean
    quantity?: boolean
    imageUrl?: boolean
    notes?: boolean
    inGradingQueue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PortfolioItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PortfolioItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cardName: string
      cardSet: string
      year: number
      grade: string
      grader: string | null
      currentValue: number
      purchasePrice: number
      purchaseDate: Date
      quantity: number
      imageUrl: string | null
      notes: string | null
      inGradingQueue: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolioItem"]>
    composites: {}
  }

  type PortfolioItemGetPayload<S extends boolean | null | undefined | PortfolioItemDefaultArgs> = $Result.GetResult<Prisma.$PortfolioItemPayload, S>

  type PortfolioItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PortfolioItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PortfolioItemCountAggregateInputType | true
    }

  export interface PortfolioItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioItem'], meta: { name: 'PortfolioItem' } }
    /**
     * Find zero or one PortfolioItem that matches the filter.
     * @param {PortfolioItemFindUniqueArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioItemFindUniqueArgs>(args: SelectSubset<T, PortfolioItemFindUniqueArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PortfolioItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PortfolioItemFindUniqueOrThrowArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PortfolioItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemFindFirstArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioItemFindFirstArgs>(args?: SelectSubset<T, PortfolioItemFindFirstArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PortfolioItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemFindFirstOrThrowArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PortfolioItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioItems
     * const portfolioItems = await prisma.portfolioItem.findMany()
     * 
     * // Get first 10 PortfolioItems
     * const portfolioItems = await prisma.portfolioItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioItemWithIdOnly = await prisma.portfolioItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioItemFindManyArgs>(args?: SelectSubset<T, PortfolioItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PortfolioItem.
     * @param {PortfolioItemCreateArgs} args - Arguments to create a PortfolioItem.
     * @example
     * // Create one PortfolioItem
     * const PortfolioItem = await prisma.portfolioItem.create({
     *   data: {
     *     // ... data to create a PortfolioItem
     *   }
     * })
     * 
     */
    create<T extends PortfolioItemCreateArgs>(args: SelectSubset<T, PortfolioItemCreateArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PortfolioItems.
     * @param {PortfolioItemCreateManyArgs} args - Arguments to create many PortfolioItems.
     * @example
     * // Create many PortfolioItems
     * const portfolioItem = await prisma.portfolioItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioItemCreateManyArgs>(args?: SelectSubset<T, PortfolioItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioItems and returns the data saved in the database.
     * @param {PortfolioItemCreateManyAndReturnArgs} args - Arguments to create many PortfolioItems.
     * @example
     * // Create many PortfolioItems
     * const portfolioItem = await prisma.portfolioItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioItems and only return the `id`
     * const portfolioItemWithIdOnly = await prisma.portfolioItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PortfolioItem.
     * @param {PortfolioItemDeleteArgs} args - Arguments to delete one PortfolioItem.
     * @example
     * // Delete one PortfolioItem
     * const PortfolioItem = await prisma.portfolioItem.delete({
     *   where: {
     *     // ... filter to delete one PortfolioItem
     *   }
     * })
     * 
     */
    delete<T extends PortfolioItemDeleteArgs>(args: SelectSubset<T, PortfolioItemDeleteArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PortfolioItem.
     * @param {PortfolioItemUpdateArgs} args - Arguments to update one PortfolioItem.
     * @example
     * // Update one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioItemUpdateArgs>(args: SelectSubset<T, PortfolioItemUpdateArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PortfolioItems.
     * @param {PortfolioItemDeleteManyArgs} args - Arguments to filter PortfolioItems to delete.
     * @example
     * // Delete a few PortfolioItems
     * const { count } = await prisma.portfolioItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioItemDeleteManyArgs>(args?: SelectSubset<T, PortfolioItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioItems
     * const portfolioItem = await prisma.portfolioItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioItemUpdateManyArgs>(args: SelectSubset<T, PortfolioItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PortfolioItem.
     * @param {PortfolioItemUpsertArgs} args - Arguments to update or create a PortfolioItem.
     * @example
     * // Update or create a PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.upsert({
     *   create: {
     *     // ... data to create a PortfolioItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioItem we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioItemUpsertArgs>(args: SelectSubset<T, PortfolioItemUpsertArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PortfolioItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemCountArgs} args - Arguments to filter PortfolioItems to count.
     * @example
     * // Count the number of PortfolioItems
     * const count = await prisma.portfolioItem.count({
     *   where: {
     *     // ... the filter for the PortfolioItems we want to count
     *   }
     * })
    **/
    count<T extends PortfolioItemCountArgs>(
      args?: Subset<T, PortfolioItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioItemAggregateArgs>(args: Subset<T, PortfolioItemAggregateArgs>): Prisma.PrismaPromise<GetPortfolioItemAggregateType<T>>

    /**
     * Group by PortfolioItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioItemGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioItem model
   */
  readonly fields: PortfolioItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioItem model
   */ 
  interface PortfolioItemFieldRefs {
    readonly id: FieldRef<"PortfolioItem", 'String'>
    readonly userId: FieldRef<"PortfolioItem", 'String'>
    readonly cardName: FieldRef<"PortfolioItem", 'String'>
    readonly cardSet: FieldRef<"PortfolioItem", 'String'>
    readonly year: FieldRef<"PortfolioItem", 'Int'>
    readonly grade: FieldRef<"PortfolioItem", 'String'>
    readonly grader: FieldRef<"PortfolioItem", 'String'>
    readonly currentValue: FieldRef<"PortfolioItem", 'Float'>
    readonly purchasePrice: FieldRef<"PortfolioItem", 'Float'>
    readonly purchaseDate: FieldRef<"PortfolioItem", 'DateTime'>
    readonly quantity: FieldRef<"PortfolioItem", 'Int'>
    readonly imageUrl: FieldRef<"PortfolioItem", 'String'>
    readonly notes: FieldRef<"PortfolioItem", 'String'>
    readonly inGradingQueue: FieldRef<"PortfolioItem", 'Boolean'>
    readonly createdAt: FieldRef<"PortfolioItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PortfolioItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioItem findUnique
   */
  export type PortfolioItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where: PortfolioItemWhereUniqueInput
  }

  /**
   * PortfolioItem findUniqueOrThrow
   */
  export type PortfolioItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where: PortfolioItemWhereUniqueInput
  }

  /**
   * PortfolioItem findFirst
   */
  export type PortfolioItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioItems.
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioItems.
     */
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }

  /**
   * PortfolioItem findFirstOrThrow
   */
  export type PortfolioItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioItems.
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioItems.
     */
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }

  /**
   * PortfolioItem findMany
   */
  export type PortfolioItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItems to fetch.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioItems.
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }

  /**
   * PortfolioItem create
   */
  export type PortfolioItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioItem.
     */
    data: XOR<PortfolioItemCreateInput, PortfolioItemUncheckedCreateInput>
  }

  /**
   * PortfolioItem createMany
   */
  export type PortfolioItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioItems.
     */
    data: PortfolioItemCreateManyInput | PortfolioItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioItem createManyAndReturn
   */
  export type PortfolioItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PortfolioItems.
     */
    data: PortfolioItemCreateManyInput | PortfolioItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioItem update
   */
  export type PortfolioItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioItem.
     */
    data: XOR<PortfolioItemUpdateInput, PortfolioItemUncheckedUpdateInput>
    /**
     * Choose, which PortfolioItem to update.
     */
    where: PortfolioItemWhereUniqueInput
  }

  /**
   * PortfolioItem updateMany
   */
  export type PortfolioItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioItems.
     */
    data: XOR<PortfolioItemUpdateManyMutationInput, PortfolioItemUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioItems to update
     */
    where?: PortfolioItemWhereInput
  }

  /**
   * PortfolioItem upsert
   */
  export type PortfolioItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioItem to update in case it exists.
     */
    where: PortfolioItemWhereUniqueInput
    /**
     * In case the PortfolioItem found by the `where` argument doesn't exist, create a new PortfolioItem with this data.
     */
    create: XOR<PortfolioItemCreateInput, PortfolioItemUncheckedCreateInput>
    /**
     * In case the PortfolioItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioItemUpdateInput, PortfolioItemUncheckedUpdateInput>
  }

  /**
   * PortfolioItem delete
   */
  export type PortfolioItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter which PortfolioItem to delete.
     */
    where: PortfolioItemWhereUniqueInput
  }

  /**
   * PortfolioItem deleteMany
   */
  export type PortfolioItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioItems to delete
     */
    where?: PortfolioItemWhereInput
  }

  /**
   * PortfolioItem without action
   */
  export type PortfolioItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
  }


  /**
   * Model Release
   */

  export type AggregateRelease = {
    _count: ReleaseCountAggregateOutputType | null
    _avg: ReleaseAvgAggregateOutputType | null
    _sum: ReleaseSumAggregateOutputType | null
    _min: ReleaseMinAggregateOutputType | null
    _max: ReleaseMaxAggregateOutputType | null
  }

  export type ReleaseAvgAggregateOutputType = {
    msrp: number | null
    estimatedResale: number | null
    hypeScore: number | null
  }

  export type ReleaseSumAggregateOutputType = {
    msrp: number | null
    estimatedResale: number | null
    hypeScore: number | null
  }

  export type ReleaseMinAggregateOutputType = {
    id: string | null
    name: string | null
    releaseDate: Date | null
    category: $Enums.Category | null
    manufacturer: string | null
    msrp: number | null
    estimatedResale: number | null
    hypeScore: number | null
    imageUrl: string | null
    printRun: string | null
    description: string | null
    isReleased: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    releaseDate: Date | null
    category: $Enums.Category | null
    manufacturer: string | null
    msrp: number | null
    estimatedResale: number | null
    hypeScore: number | null
    imageUrl: string | null
    printRun: string | null
    description: string | null
    isReleased: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseCountAggregateOutputType = {
    id: number
    name: number
    releaseDate: number
    category: number
    manufacturer: number
    msrp: number
    estimatedResale: number
    hypeScore: number
    imageUrl: number
    topChases: number
    printRun: number
    description: number
    isReleased: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReleaseAvgAggregateInputType = {
    msrp?: true
    estimatedResale?: true
    hypeScore?: true
  }

  export type ReleaseSumAggregateInputType = {
    msrp?: true
    estimatedResale?: true
    hypeScore?: true
  }

  export type ReleaseMinAggregateInputType = {
    id?: true
    name?: true
    releaseDate?: true
    category?: true
    manufacturer?: true
    msrp?: true
    estimatedResale?: true
    hypeScore?: true
    imageUrl?: true
    printRun?: true
    description?: true
    isReleased?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseMaxAggregateInputType = {
    id?: true
    name?: true
    releaseDate?: true
    category?: true
    manufacturer?: true
    msrp?: true
    estimatedResale?: true
    hypeScore?: true
    imageUrl?: true
    printRun?: true
    description?: true
    isReleased?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseCountAggregateInputType = {
    id?: true
    name?: true
    releaseDate?: true
    category?: true
    manufacturer?: true
    msrp?: true
    estimatedResale?: true
    hypeScore?: true
    imageUrl?: true
    topChases?: true
    printRun?: true
    description?: true
    isReleased?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReleaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Release to aggregate.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Releases
    **/
    _count?: true | ReleaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReleaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReleaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReleaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReleaseMaxAggregateInputType
  }

  export type GetReleaseAggregateType<T extends ReleaseAggregateArgs> = {
        [P in keyof T & keyof AggregateRelease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelease[P]>
      : GetScalarType<T[P], AggregateRelease[P]>
  }




  export type ReleaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseWhereInput
    orderBy?: ReleaseOrderByWithAggregationInput | ReleaseOrderByWithAggregationInput[]
    by: ReleaseScalarFieldEnum[] | ReleaseScalarFieldEnum
    having?: ReleaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleaseCountAggregateInputType | true
    _avg?: ReleaseAvgAggregateInputType
    _sum?: ReleaseSumAggregateInputType
    _min?: ReleaseMinAggregateInputType
    _max?: ReleaseMaxAggregateInputType
  }

  export type ReleaseGroupByOutputType = {
    id: string
    name: string
    releaseDate: Date
    category: $Enums.Category
    manufacturer: string
    msrp: number
    estimatedResale: number | null
    hypeScore: number | null
    imageUrl: string | null
    topChases: string[]
    printRun: string | null
    description: string | null
    isReleased: boolean
    createdAt: Date
    updatedAt: Date
    _count: ReleaseCountAggregateOutputType | null
    _avg: ReleaseAvgAggregateOutputType | null
    _sum: ReleaseSumAggregateOutputType | null
    _min: ReleaseMinAggregateOutputType | null
    _max: ReleaseMaxAggregateOutputType | null
  }

  type GetReleaseGroupByPayload<T extends ReleaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleaseGroupByOutputType[P]>
            : GetScalarType<T[P], ReleaseGroupByOutputType[P]>
        }
      >
    >


  export type ReleaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    releaseDate?: boolean
    category?: boolean
    manufacturer?: boolean
    msrp?: boolean
    estimatedResale?: boolean
    hypeScore?: boolean
    imageUrl?: boolean
    topChases?: boolean
    printRun?: boolean
    description?: boolean
    isReleased?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Release$productsArgs<ExtArgs>
    _count?: boolean | ReleaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["release"]>

  export type ReleaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    releaseDate?: boolean
    category?: boolean
    manufacturer?: boolean
    msrp?: boolean
    estimatedResale?: boolean
    hypeScore?: boolean
    imageUrl?: boolean
    topChases?: boolean
    printRun?: boolean
    description?: boolean
    isReleased?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["release"]>

  export type ReleaseSelectScalar = {
    id?: boolean
    name?: boolean
    releaseDate?: boolean
    category?: boolean
    manufacturer?: boolean
    msrp?: boolean
    estimatedResale?: boolean
    hypeScore?: boolean
    imageUrl?: boolean
    topChases?: boolean
    printRun?: boolean
    description?: boolean
    isReleased?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReleaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Release$productsArgs<ExtArgs>
    _count?: boolean | ReleaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReleaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReleasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Release"
    objects: {
      products: Prisma.$ReleaseProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      releaseDate: Date
      category: $Enums.Category
      manufacturer: string
      msrp: number
      estimatedResale: number | null
      hypeScore: number | null
      imageUrl: string | null
      topChases: string[]
      printRun: string | null
      description: string | null
      isReleased: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["release"]>
    composites: {}
  }

  type ReleaseGetPayload<S extends boolean | null | undefined | ReleaseDefaultArgs> = $Result.GetResult<Prisma.$ReleasePayload, S>

  type ReleaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReleaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReleaseCountAggregateInputType | true
    }

  export interface ReleaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Release'], meta: { name: 'Release' } }
    /**
     * Find zero or one Release that matches the filter.
     * @param {ReleaseFindUniqueArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReleaseFindUniqueArgs>(args: SelectSubset<T, ReleaseFindUniqueArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Release that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReleaseFindUniqueOrThrowArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReleaseFindUniqueOrThrowArgs>(args: SelectSubset<T, ReleaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Release that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseFindFirstArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReleaseFindFirstArgs>(args?: SelectSubset<T, ReleaseFindFirstArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Release that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseFindFirstOrThrowArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReleaseFindFirstOrThrowArgs>(args?: SelectSubset<T, ReleaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Releases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Releases
     * const releases = await prisma.release.findMany()
     * 
     * // Get first 10 Releases
     * const releases = await prisma.release.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const releaseWithIdOnly = await prisma.release.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReleaseFindManyArgs>(args?: SelectSubset<T, ReleaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Release.
     * @param {ReleaseCreateArgs} args - Arguments to create a Release.
     * @example
     * // Create one Release
     * const Release = await prisma.release.create({
     *   data: {
     *     // ... data to create a Release
     *   }
     * })
     * 
     */
    create<T extends ReleaseCreateArgs>(args: SelectSubset<T, ReleaseCreateArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Releases.
     * @param {ReleaseCreateManyArgs} args - Arguments to create many Releases.
     * @example
     * // Create many Releases
     * const release = await prisma.release.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReleaseCreateManyArgs>(args?: SelectSubset<T, ReleaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Releases and returns the data saved in the database.
     * @param {ReleaseCreateManyAndReturnArgs} args - Arguments to create many Releases.
     * @example
     * // Create many Releases
     * const release = await prisma.release.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Releases and only return the `id`
     * const releaseWithIdOnly = await prisma.release.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReleaseCreateManyAndReturnArgs>(args?: SelectSubset<T, ReleaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Release.
     * @param {ReleaseDeleteArgs} args - Arguments to delete one Release.
     * @example
     * // Delete one Release
     * const Release = await prisma.release.delete({
     *   where: {
     *     // ... filter to delete one Release
     *   }
     * })
     * 
     */
    delete<T extends ReleaseDeleteArgs>(args: SelectSubset<T, ReleaseDeleteArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Release.
     * @param {ReleaseUpdateArgs} args - Arguments to update one Release.
     * @example
     * // Update one Release
     * const release = await prisma.release.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReleaseUpdateArgs>(args: SelectSubset<T, ReleaseUpdateArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Releases.
     * @param {ReleaseDeleteManyArgs} args - Arguments to filter Releases to delete.
     * @example
     * // Delete a few Releases
     * const { count } = await prisma.release.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReleaseDeleteManyArgs>(args?: SelectSubset<T, ReleaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Releases
     * const release = await prisma.release.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReleaseUpdateManyArgs>(args: SelectSubset<T, ReleaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Release.
     * @param {ReleaseUpsertArgs} args - Arguments to update or create a Release.
     * @example
     * // Update or create a Release
     * const release = await prisma.release.upsert({
     *   create: {
     *     // ... data to create a Release
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Release we want to update
     *   }
     * })
     */
    upsert<T extends ReleaseUpsertArgs>(args: SelectSubset<T, ReleaseUpsertArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCountArgs} args - Arguments to filter Releases to count.
     * @example
     * // Count the number of Releases
     * const count = await prisma.release.count({
     *   where: {
     *     // ... the filter for the Releases we want to count
     *   }
     * })
    **/
    count<T extends ReleaseCountArgs>(
      args?: Subset<T, ReleaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Release.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleaseAggregateArgs>(args: Subset<T, ReleaseAggregateArgs>): Prisma.PrismaPromise<GetReleaseAggregateType<T>>

    /**
     * Group by Release.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReleaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReleaseGroupByArgs['orderBy'] }
        : { orderBy?: ReleaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReleaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Release model
   */
  readonly fields: ReleaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Release.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReleaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Release$productsArgs<ExtArgs> = {}>(args?: Subset<T, Release$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Release model
   */ 
  interface ReleaseFieldRefs {
    readonly id: FieldRef<"Release", 'String'>
    readonly name: FieldRef<"Release", 'String'>
    readonly releaseDate: FieldRef<"Release", 'DateTime'>
    readonly category: FieldRef<"Release", 'Category'>
    readonly manufacturer: FieldRef<"Release", 'String'>
    readonly msrp: FieldRef<"Release", 'Float'>
    readonly estimatedResale: FieldRef<"Release", 'Float'>
    readonly hypeScore: FieldRef<"Release", 'Float'>
    readonly imageUrl: FieldRef<"Release", 'String'>
    readonly topChases: FieldRef<"Release", 'String[]'>
    readonly printRun: FieldRef<"Release", 'String'>
    readonly description: FieldRef<"Release", 'String'>
    readonly isReleased: FieldRef<"Release", 'Boolean'>
    readonly createdAt: FieldRef<"Release", 'DateTime'>
    readonly updatedAt: FieldRef<"Release", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Release findUnique
   */
  export type ReleaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release findUniqueOrThrow
   */
  export type ReleaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release findFirst
   */
  export type ReleaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Releases.
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Releases.
     */
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * Release findFirstOrThrow
   */
  export type ReleaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Releases.
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Releases.
     */
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * Release findMany
   */
  export type ReleaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Releases to fetch.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Releases.
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Releases.
     */
    skip?: number
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * Release create
   */
  export type ReleaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Release.
     */
    data: XOR<ReleaseCreateInput, ReleaseUncheckedCreateInput>
  }

  /**
   * Release createMany
   */
  export type ReleaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Releases.
     */
    data: ReleaseCreateManyInput | ReleaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Release createManyAndReturn
   */
  export type ReleaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Releases.
     */
    data: ReleaseCreateManyInput | ReleaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Release update
   */
  export type ReleaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Release.
     */
    data: XOR<ReleaseUpdateInput, ReleaseUncheckedUpdateInput>
    /**
     * Choose, which Release to update.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release updateMany
   */
  export type ReleaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Releases.
     */
    data: XOR<ReleaseUpdateManyMutationInput, ReleaseUncheckedUpdateManyInput>
    /**
     * Filter which Releases to update
     */
    where?: ReleaseWhereInput
  }

  /**
   * Release upsert
   */
  export type ReleaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Release to update in case it exists.
     */
    where: ReleaseWhereUniqueInput
    /**
     * In case the Release found by the `where` argument doesn't exist, create a new Release with this data.
     */
    create: XOR<ReleaseCreateInput, ReleaseUncheckedCreateInput>
    /**
     * In case the Release was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReleaseUpdateInput, ReleaseUncheckedUpdateInput>
  }

  /**
   * Release delete
   */
  export type ReleaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter which Release to delete.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release deleteMany
   */
  export type ReleaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Releases to delete
     */
    where?: ReleaseWhereInput
  }

  /**
   * Release.products
   */
  export type Release$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    where?: ReleaseProductWhereInput
    orderBy?: ReleaseProductOrderByWithRelationInput | ReleaseProductOrderByWithRelationInput[]
    cursor?: ReleaseProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReleaseProductScalarFieldEnum | ReleaseProductScalarFieldEnum[]
  }

  /**
   * Release without action
   */
  export type ReleaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
  }


  /**
   * Model ReleaseProduct
   */

  export type AggregateReleaseProduct = {
    _count: ReleaseProductCountAggregateOutputType | null
    _avg: ReleaseProductAvgAggregateOutputType | null
    _sum: ReleaseProductSumAggregateOutputType | null
    _min: ReleaseProductMinAggregateOutputType | null
    _max: ReleaseProductMaxAggregateOutputType | null
  }

  export type ReleaseProductAvgAggregateOutputType = {
    msrp: number | null
    estimatedResale: number | null
  }

  export type ReleaseProductSumAggregateOutputType = {
    msrp: number | null
    estimatedResale: number | null
  }

  export type ReleaseProductMinAggregateOutputType = {
    id: string | null
    releaseId: string | null
    name: string | null
    productType: string | null
    category: $Enums.Category | null
    msrp: number | null
    estimatedResale: number | null
    releaseDate: Date | null
    preorderDate: Date | null
    imageUrl: string | null
    buyUrl: string | null
    contentsSummary: string | null
    sourceTier: $Enums.SourceTier | null
    sourceUrl: string | null
    confidence: $Enums.Confidence | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseProductMaxAggregateOutputType = {
    id: string | null
    releaseId: string | null
    name: string | null
    productType: string | null
    category: $Enums.Category | null
    msrp: number | null
    estimatedResale: number | null
    releaseDate: Date | null
    preorderDate: Date | null
    imageUrl: string | null
    buyUrl: string | null
    contentsSummary: string | null
    sourceTier: $Enums.SourceTier | null
    sourceUrl: string | null
    confidence: $Enums.Confidence | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseProductCountAggregateOutputType = {
    id: number
    releaseId: number
    name: number
    productType: number
    category: number
    msrp: number
    estimatedResale: number
    releaseDate: number
    preorderDate: number
    imageUrl: number
    buyUrl: number
    contentsSummary: number
    sourceTier: number
    sourceUrl: number
    confidence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReleaseProductAvgAggregateInputType = {
    msrp?: true
    estimatedResale?: true
  }

  export type ReleaseProductSumAggregateInputType = {
    msrp?: true
    estimatedResale?: true
  }

  export type ReleaseProductMinAggregateInputType = {
    id?: true
    releaseId?: true
    name?: true
    productType?: true
    category?: true
    msrp?: true
    estimatedResale?: true
    releaseDate?: true
    preorderDate?: true
    imageUrl?: true
    buyUrl?: true
    contentsSummary?: true
    sourceTier?: true
    sourceUrl?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseProductMaxAggregateInputType = {
    id?: true
    releaseId?: true
    name?: true
    productType?: true
    category?: true
    msrp?: true
    estimatedResale?: true
    releaseDate?: true
    preorderDate?: true
    imageUrl?: true
    buyUrl?: true
    contentsSummary?: true
    sourceTier?: true
    sourceUrl?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseProductCountAggregateInputType = {
    id?: true
    releaseId?: true
    name?: true
    productType?: true
    category?: true
    msrp?: true
    estimatedResale?: true
    releaseDate?: true
    preorderDate?: true
    imageUrl?: true
    buyUrl?: true
    contentsSummary?: true
    sourceTier?: true
    sourceUrl?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReleaseProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseProduct to aggregate.
     */
    where?: ReleaseProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleaseProducts to fetch.
     */
    orderBy?: ReleaseProductOrderByWithRelationInput | ReleaseProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReleaseProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleaseProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleaseProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReleaseProducts
    **/
    _count?: true | ReleaseProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReleaseProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReleaseProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReleaseProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReleaseProductMaxAggregateInputType
  }

  export type GetReleaseProductAggregateType<T extends ReleaseProductAggregateArgs> = {
        [P in keyof T & keyof AggregateReleaseProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReleaseProduct[P]>
      : GetScalarType<T[P], AggregateReleaseProduct[P]>
  }




  export type ReleaseProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseProductWhereInput
    orderBy?: ReleaseProductOrderByWithAggregationInput | ReleaseProductOrderByWithAggregationInput[]
    by: ReleaseProductScalarFieldEnum[] | ReleaseProductScalarFieldEnum
    having?: ReleaseProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleaseProductCountAggregateInputType | true
    _avg?: ReleaseProductAvgAggregateInputType
    _sum?: ReleaseProductSumAggregateInputType
    _min?: ReleaseProductMinAggregateInputType
    _max?: ReleaseProductMaxAggregateInputType
  }

  export type ReleaseProductGroupByOutputType = {
    id: string
    releaseId: string
    name: string
    productType: string
    category: $Enums.Category
    msrp: number | null
    estimatedResale: number | null
    releaseDate: Date | null
    preorderDate: Date | null
    imageUrl: string | null
    buyUrl: string | null
    contentsSummary: string | null
    sourceTier: $Enums.SourceTier | null
    sourceUrl: string | null
    confidence: $Enums.Confidence
    createdAt: Date
    updatedAt: Date
    _count: ReleaseProductCountAggregateOutputType | null
    _avg: ReleaseProductAvgAggregateOutputType | null
    _sum: ReleaseProductSumAggregateOutputType | null
    _min: ReleaseProductMinAggregateOutputType | null
    _max: ReleaseProductMaxAggregateOutputType | null
  }

  type GetReleaseProductGroupByPayload<T extends ReleaseProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleaseProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleaseProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleaseProductGroupByOutputType[P]>
            : GetScalarType<T[P], ReleaseProductGroupByOutputType[P]>
        }
      >
    >


  export type ReleaseProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    name?: boolean
    productType?: boolean
    category?: boolean
    msrp?: boolean
    estimatedResale?: boolean
    releaseDate?: boolean
    preorderDate?: boolean
    imageUrl?: boolean
    buyUrl?: boolean
    contentsSummary?: boolean
    sourceTier?: boolean
    sourceUrl?: boolean
    confidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
    changes?: boolean | ReleaseProduct$changesArgs<ExtArgs>
    _count?: boolean | ReleaseProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseProduct"]>

  export type ReleaseProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    name?: boolean
    productType?: boolean
    category?: boolean
    msrp?: boolean
    estimatedResale?: boolean
    releaseDate?: boolean
    preorderDate?: boolean
    imageUrl?: boolean
    buyUrl?: boolean
    contentsSummary?: boolean
    sourceTier?: boolean
    sourceUrl?: boolean
    confidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseProduct"]>

  export type ReleaseProductSelectScalar = {
    id?: boolean
    releaseId?: boolean
    name?: boolean
    productType?: boolean
    category?: boolean
    msrp?: boolean
    estimatedResale?: boolean
    releaseDate?: boolean
    preorderDate?: boolean
    imageUrl?: boolean
    buyUrl?: boolean
    contentsSummary?: boolean
    sourceTier?: boolean
    sourceUrl?: boolean
    confidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReleaseProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
    changes?: boolean | ReleaseProduct$changesArgs<ExtArgs>
    _count?: boolean | ReleaseProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReleaseProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }

  export type $ReleaseProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReleaseProduct"
    objects: {
      release: Prisma.$ReleasePayload<ExtArgs>
      changes: Prisma.$ReleaseProductChangePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      releaseId: string
      name: string
      productType: string
      category: $Enums.Category
      msrp: number | null
      estimatedResale: number | null
      releaseDate: Date | null
      preorderDate: Date | null
      imageUrl: string | null
      buyUrl: string | null
      contentsSummary: string | null
      sourceTier: $Enums.SourceTier | null
      sourceUrl: string | null
      confidence: $Enums.Confidence
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["releaseProduct"]>
    composites: {}
  }

  type ReleaseProductGetPayload<S extends boolean | null | undefined | ReleaseProductDefaultArgs> = $Result.GetResult<Prisma.$ReleaseProductPayload, S>

  type ReleaseProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReleaseProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReleaseProductCountAggregateInputType | true
    }

  export interface ReleaseProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReleaseProduct'], meta: { name: 'ReleaseProduct' } }
    /**
     * Find zero or one ReleaseProduct that matches the filter.
     * @param {ReleaseProductFindUniqueArgs} args - Arguments to find a ReleaseProduct
     * @example
     * // Get one ReleaseProduct
     * const releaseProduct = await prisma.releaseProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReleaseProductFindUniqueArgs>(args: SelectSubset<T, ReleaseProductFindUniqueArgs<ExtArgs>>): Prisma__ReleaseProductClient<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReleaseProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReleaseProductFindUniqueOrThrowArgs} args - Arguments to find a ReleaseProduct
     * @example
     * // Get one ReleaseProduct
     * const releaseProduct = await prisma.releaseProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReleaseProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ReleaseProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReleaseProductClient<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReleaseProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductFindFirstArgs} args - Arguments to find a ReleaseProduct
     * @example
     * // Get one ReleaseProduct
     * const releaseProduct = await prisma.releaseProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReleaseProductFindFirstArgs>(args?: SelectSubset<T, ReleaseProductFindFirstArgs<ExtArgs>>): Prisma__ReleaseProductClient<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReleaseProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductFindFirstOrThrowArgs} args - Arguments to find a ReleaseProduct
     * @example
     * // Get one ReleaseProduct
     * const releaseProduct = await prisma.releaseProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReleaseProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ReleaseProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReleaseProductClient<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReleaseProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReleaseProducts
     * const releaseProducts = await prisma.releaseProduct.findMany()
     * 
     * // Get first 10 ReleaseProducts
     * const releaseProducts = await prisma.releaseProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const releaseProductWithIdOnly = await prisma.releaseProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReleaseProductFindManyArgs>(args?: SelectSubset<T, ReleaseProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReleaseProduct.
     * @param {ReleaseProductCreateArgs} args - Arguments to create a ReleaseProduct.
     * @example
     * // Create one ReleaseProduct
     * const ReleaseProduct = await prisma.releaseProduct.create({
     *   data: {
     *     // ... data to create a ReleaseProduct
     *   }
     * })
     * 
     */
    create<T extends ReleaseProductCreateArgs>(args: SelectSubset<T, ReleaseProductCreateArgs<ExtArgs>>): Prisma__ReleaseProductClient<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReleaseProducts.
     * @param {ReleaseProductCreateManyArgs} args - Arguments to create many ReleaseProducts.
     * @example
     * // Create many ReleaseProducts
     * const releaseProduct = await prisma.releaseProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReleaseProductCreateManyArgs>(args?: SelectSubset<T, ReleaseProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReleaseProducts and returns the data saved in the database.
     * @param {ReleaseProductCreateManyAndReturnArgs} args - Arguments to create many ReleaseProducts.
     * @example
     * // Create many ReleaseProducts
     * const releaseProduct = await prisma.releaseProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReleaseProducts and only return the `id`
     * const releaseProductWithIdOnly = await prisma.releaseProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReleaseProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ReleaseProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReleaseProduct.
     * @param {ReleaseProductDeleteArgs} args - Arguments to delete one ReleaseProduct.
     * @example
     * // Delete one ReleaseProduct
     * const ReleaseProduct = await prisma.releaseProduct.delete({
     *   where: {
     *     // ... filter to delete one ReleaseProduct
     *   }
     * })
     * 
     */
    delete<T extends ReleaseProductDeleteArgs>(args: SelectSubset<T, ReleaseProductDeleteArgs<ExtArgs>>): Prisma__ReleaseProductClient<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReleaseProduct.
     * @param {ReleaseProductUpdateArgs} args - Arguments to update one ReleaseProduct.
     * @example
     * // Update one ReleaseProduct
     * const releaseProduct = await prisma.releaseProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReleaseProductUpdateArgs>(args: SelectSubset<T, ReleaseProductUpdateArgs<ExtArgs>>): Prisma__ReleaseProductClient<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReleaseProducts.
     * @param {ReleaseProductDeleteManyArgs} args - Arguments to filter ReleaseProducts to delete.
     * @example
     * // Delete a few ReleaseProducts
     * const { count } = await prisma.releaseProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReleaseProductDeleteManyArgs>(args?: SelectSubset<T, ReleaseProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReleaseProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReleaseProducts
     * const releaseProduct = await prisma.releaseProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReleaseProductUpdateManyArgs>(args: SelectSubset<T, ReleaseProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReleaseProduct.
     * @param {ReleaseProductUpsertArgs} args - Arguments to update or create a ReleaseProduct.
     * @example
     * // Update or create a ReleaseProduct
     * const releaseProduct = await prisma.releaseProduct.upsert({
     *   create: {
     *     // ... data to create a ReleaseProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReleaseProduct we want to update
     *   }
     * })
     */
    upsert<T extends ReleaseProductUpsertArgs>(args: SelectSubset<T, ReleaseProductUpsertArgs<ExtArgs>>): Prisma__ReleaseProductClient<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReleaseProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductCountArgs} args - Arguments to filter ReleaseProducts to count.
     * @example
     * // Count the number of ReleaseProducts
     * const count = await prisma.releaseProduct.count({
     *   where: {
     *     // ... the filter for the ReleaseProducts we want to count
     *   }
     * })
    **/
    count<T extends ReleaseProductCountArgs>(
      args?: Subset<T, ReleaseProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleaseProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReleaseProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleaseProductAggregateArgs>(args: Subset<T, ReleaseProductAggregateArgs>): Prisma.PrismaPromise<GetReleaseProductAggregateType<T>>

    /**
     * Group by ReleaseProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReleaseProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReleaseProductGroupByArgs['orderBy'] }
        : { orderBy?: ReleaseProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReleaseProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReleaseProduct model
   */
  readonly fields: ReleaseProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReleaseProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReleaseProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    release<T extends ReleaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReleaseDefaultArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changes<T extends ReleaseProduct$changesArgs<ExtArgs> = {}>(args?: Subset<T, ReleaseProduct$changesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReleaseProduct model
   */ 
  interface ReleaseProductFieldRefs {
    readonly id: FieldRef<"ReleaseProduct", 'String'>
    readonly releaseId: FieldRef<"ReleaseProduct", 'String'>
    readonly name: FieldRef<"ReleaseProduct", 'String'>
    readonly productType: FieldRef<"ReleaseProduct", 'String'>
    readonly category: FieldRef<"ReleaseProduct", 'Category'>
    readonly msrp: FieldRef<"ReleaseProduct", 'Float'>
    readonly estimatedResale: FieldRef<"ReleaseProduct", 'Float'>
    readonly releaseDate: FieldRef<"ReleaseProduct", 'DateTime'>
    readonly preorderDate: FieldRef<"ReleaseProduct", 'DateTime'>
    readonly imageUrl: FieldRef<"ReleaseProduct", 'String'>
    readonly buyUrl: FieldRef<"ReleaseProduct", 'String'>
    readonly contentsSummary: FieldRef<"ReleaseProduct", 'String'>
    readonly sourceTier: FieldRef<"ReleaseProduct", 'SourceTier'>
    readonly sourceUrl: FieldRef<"ReleaseProduct", 'String'>
    readonly confidence: FieldRef<"ReleaseProduct", 'Confidence'>
    readonly createdAt: FieldRef<"ReleaseProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"ReleaseProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReleaseProduct findUnique
   */
  export type ReleaseProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProduct to fetch.
     */
    where: ReleaseProductWhereUniqueInput
  }

  /**
   * ReleaseProduct findUniqueOrThrow
   */
  export type ReleaseProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProduct to fetch.
     */
    where: ReleaseProductWhereUniqueInput
  }

  /**
   * ReleaseProduct findFirst
   */
  export type ReleaseProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProduct to fetch.
     */
    where?: ReleaseProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleaseProducts to fetch.
     */
    orderBy?: ReleaseProductOrderByWithRelationInput | ReleaseProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReleaseProducts.
     */
    cursor?: ReleaseProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleaseProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleaseProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReleaseProducts.
     */
    distinct?: ReleaseProductScalarFieldEnum | ReleaseProductScalarFieldEnum[]
  }

  /**
   * ReleaseProduct findFirstOrThrow
   */
  export type ReleaseProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProduct to fetch.
     */
    where?: ReleaseProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleaseProducts to fetch.
     */
    orderBy?: ReleaseProductOrderByWithRelationInput | ReleaseProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReleaseProducts.
     */
    cursor?: ReleaseProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleaseProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleaseProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReleaseProducts.
     */
    distinct?: ReleaseProductScalarFieldEnum | ReleaseProductScalarFieldEnum[]
  }

  /**
   * ReleaseProduct findMany
   */
  export type ReleaseProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProducts to fetch.
     */
    where?: ReleaseProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleaseProducts to fetch.
     */
    orderBy?: ReleaseProductOrderByWithRelationInput | ReleaseProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReleaseProducts.
     */
    cursor?: ReleaseProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleaseProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleaseProducts.
     */
    skip?: number
    distinct?: ReleaseProductScalarFieldEnum | ReleaseProductScalarFieldEnum[]
  }

  /**
   * ReleaseProduct create
   */
  export type ReleaseProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ReleaseProduct.
     */
    data: XOR<ReleaseProductCreateInput, ReleaseProductUncheckedCreateInput>
  }

  /**
   * ReleaseProduct createMany
   */
  export type ReleaseProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReleaseProducts.
     */
    data: ReleaseProductCreateManyInput | ReleaseProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReleaseProduct createManyAndReturn
   */
  export type ReleaseProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReleaseProducts.
     */
    data: ReleaseProductCreateManyInput | ReleaseProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReleaseProduct update
   */
  export type ReleaseProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ReleaseProduct.
     */
    data: XOR<ReleaseProductUpdateInput, ReleaseProductUncheckedUpdateInput>
    /**
     * Choose, which ReleaseProduct to update.
     */
    where: ReleaseProductWhereUniqueInput
  }

  /**
   * ReleaseProduct updateMany
   */
  export type ReleaseProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReleaseProducts.
     */
    data: XOR<ReleaseProductUpdateManyMutationInput, ReleaseProductUncheckedUpdateManyInput>
    /**
     * Filter which ReleaseProducts to update
     */
    where?: ReleaseProductWhereInput
  }

  /**
   * ReleaseProduct upsert
   */
  export type ReleaseProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ReleaseProduct to update in case it exists.
     */
    where: ReleaseProductWhereUniqueInput
    /**
     * In case the ReleaseProduct found by the `where` argument doesn't exist, create a new ReleaseProduct with this data.
     */
    create: XOR<ReleaseProductCreateInput, ReleaseProductUncheckedCreateInput>
    /**
     * In case the ReleaseProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReleaseProductUpdateInput, ReleaseProductUncheckedUpdateInput>
  }

  /**
   * ReleaseProduct delete
   */
  export type ReleaseProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
    /**
     * Filter which ReleaseProduct to delete.
     */
    where: ReleaseProductWhereUniqueInput
  }

  /**
   * ReleaseProduct deleteMany
   */
  export type ReleaseProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseProducts to delete
     */
    where?: ReleaseProductWhereInput
  }

  /**
   * ReleaseProduct.changes
   */
  export type ReleaseProduct$changesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    where?: ReleaseProductChangeWhereInput
    orderBy?: ReleaseProductChangeOrderByWithRelationInput | ReleaseProductChangeOrderByWithRelationInput[]
    cursor?: ReleaseProductChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReleaseProductChangeScalarFieldEnum | ReleaseProductChangeScalarFieldEnum[]
  }

  /**
   * ReleaseProduct without action
   */
  export type ReleaseProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProduct
     */
    select?: ReleaseProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductInclude<ExtArgs> | null
  }


  /**
   * Model ReleaseProductChange
   */

  export type AggregateReleaseProductChange = {
    _count: ReleaseProductChangeCountAggregateOutputType | null
    _min: ReleaseProductChangeMinAggregateOutputType | null
    _max: ReleaseProductChangeMaxAggregateOutputType | null
  }

  export type ReleaseProductChangeMinAggregateOutputType = {
    id: string | null
    releaseProductId: string | null
    field: string | null
    oldValue: string | null
    newValue: string | null
    detectedAt: Date | null
    sourceUrl: string | null
  }

  export type ReleaseProductChangeMaxAggregateOutputType = {
    id: string | null
    releaseProductId: string | null
    field: string | null
    oldValue: string | null
    newValue: string | null
    detectedAt: Date | null
    sourceUrl: string | null
  }

  export type ReleaseProductChangeCountAggregateOutputType = {
    id: number
    releaseProductId: number
    field: number
    oldValue: number
    newValue: number
    detectedAt: number
    sourceUrl: number
    _all: number
  }


  export type ReleaseProductChangeMinAggregateInputType = {
    id?: true
    releaseProductId?: true
    field?: true
    oldValue?: true
    newValue?: true
    detectedAt?: true
    sourceUrl?: true
  }

  export type ReleaseProductChangeMaxAggregateInputType = {
    id?: true
    releaseProductId?: true
    field?: true
    oldValue?: true
    newValue?: true
    detectedAt?: true
    sourceUrl?: true
  }

  export type ReleaseProductChangeCountAggregateInputType = {
    id?: true
    releaseProductId?: true
    field?: true
    oldValue?: true
    newValue?: true
    detectedAt?: true
    sourceUrl?: true
    _all?: true
  }

  export type ReleaseProductChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseProductChange to aggregate.
     */
    where?: ReleaseProductChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleaseProductChanges to fetch.
     */
    orderBy?: ReleaseProductChangeOrderByWithRelationInput | ReleaseProductChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReleaseProductChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleaseProductChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleaseProductChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReleaseProductChanges
    **/
    _count?: true | ReleaseProductChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReleaseProductChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReleaseProductChangeMaxAggregateInputType
  }

  export type GetReleaseProductChangeAggregateType<T extends ReleaseProductChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateReleaseProductChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReleaseProductChange[P]>
      : GetScalarType<T[P], AggregateReleaseProductChange[P]>
  }




  export type ReleaseProductChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseProductChangeWhereInput
    orderBy?: ReleaseProductChangeOrderByWithAggregationInput | ReleaseProductChangeOrderByWithAggregationInput[]
    by: ReleaseProductChangeScalarFieldEnum[] | ReleaseProductChangeScalarFieldEnum
    having?: ReleaseProductChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleaseProductChangeCountAggregateInputType | true
    _min?: ReleaseProductChangeMinAggregateInputType
    _max?: ReleaseProductChangeMaxAggregateInputType
  }

  export type ReleaseProductChangeGroupByOutputType = {
    id: string
    releaseProductId: string
    field: string
    oldValue: string | null
    newValue: string | null
    detectedAt: Date
    sourceUrl: string | null
    _count: ReleaseProductChangeCountAggregateOutputType | null
    _min: ReleaseProductChangeMinAggregateOutputType | null
    _max: ReleaseProductChangeMaxAggregateOutputType | null
  }

  type GetReleaseProductChangeGroupByPayload<T extends ReleaseProductChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleaseProductChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleaseProductChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleaseProductChangeGroupByOutputType[P]>
            : GetScalarType<T[P], ReleaseProductChangeGroupByOutputType[P]>
        }
      >
    >


  export type ReleaseProductChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseProductId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    detectedAt?: boolean
    sourceUrl?: boolean
    releaseProduct?: boolean | ReleaseProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseProductChange"]>

  export type ReleaseProductChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseProductId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    detectedAt?: boolean
    sourceUrl?: boolean
    releaseProduct?: boolean | ReleaseProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseProductChange"]>

  export type ReleaseProductChangeSelectScalar = {
    id?: boolean
    releaseProductId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    detectedAt?: boolean
    sourceUrl?: boolean
  }

  export type ReleaseProductChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    releaseProduct?: boolean | ReleaseProductDefaultArgs<ExtArgs>
  }
  export type ReleaseProductChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    releaseProduct?: boolean | ReleaseProductDefaultArgs<ExtArgs>
  }

  export type $ReleaseProductChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReleaseProductChange"
    objects: {
      releaseProduct: Prisma.$ReleaseProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      releaseProductId: string
      field: string
      oldValue: string | null
      newValue: string | null
      detectedAt: Date
      sourceUrl: string | null
    }, ExtArgs["result"]["releaseProductChange"]>
    composites: {}
  }

  type ReleaseProductChangeGetPayload<S extends boolean | null | undefined | ReleaseProductChangeDefaultArgs> = $Result.GetResult<Prisma.$ReleaseProductChangePayload, S>

  type ReleaseProductChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReleaseProductChangeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReleaseProductChangeCountAggregateInputType | true
    }

  export interface ReleaseProductChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReleaseProductChange'], meta: { name: 'ReleaseProductChange' } }
    /**
     * Find zero or one ReleaseProductChange that matches the filter.
     * @param {ReleaseProductChangeFindUniqueArgs} args - Arguments to find a ReleaseProductChange
     * @example
     * // Get one ReleaseProductChange
     * const releaseProductChange = await prisma.releaseProductChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReleaseProductChangeFindUniqueArgs>(args: SelectSubset<T, ReleaseProductChangeFindUniqueArgs<ExtArgs>>): Prisma__ReleaseProductChangeClient<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReleaseProductChange that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReleaseProductChangeFindUniqueOrThrowArgs} args - Arguments to find a ReleaseProductChange
     * @example
     * // Get one ReleaseProductChange
     * const releaseProductChange = await prisma.releaseProductChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReleaseProductChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, ReleaseProductChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReleaseProductChangeClient<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReleaseProductChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductChangeFindFirstArgs} args - Arguments to find a ReleaseProductChange
     * @example
     * // Get one ReleaseProductChange
     * const releaseProductChange = await prisma.releaseProductChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReleaseProductChangeFindFirstArgs>(args?: SelectSubset<T, ReleaseProductChangeFindFirstArgs<ExtArgs>>): Prisma__ReleaseProductChangeClient<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReleaseProductChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductChangeFindFirstOrThrowArgs} args - Arguments to find a ReleaseProductChange
     * @example
     * // Get one ReleaseProductChange
     * const releaseProductChange = await prisma.releaseProductChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReleaseProductChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, ReleaseProductChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReleaseProductChangeClient<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReleaseProductChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReleaseProductChanges
     * const releaseProductChanges = await prisma.releaseProductChange.findMany()
     * 
     * // Get first 10 ReleaseProductChanges
     * const releaseProductChanges = await prisma.releaseProductChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const releaseProductChangeWithIdOnly = await prisma.releaseProductChange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReleaseProductChangeFindManyArgs>(args?: SelectSubset<T, ReleaseProductChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReleaseProductChange.
     * @param {ReleaseProductChangeCreateArgs} args - Arguments to create a ReleaseProductChange.
     * @example
     * // Create one ReleaseProductChange
     * const ReleaseProductChange = await prisma.releaseProductChange.create({
     *   data: {
     *     // ... data to create a ReleaseProductChange
     *   }
     * })
     * 
     */
    create<T extends ReleaseProductChangeCreateArgs>(args: SelectSubset<T, ReleaseProductChangeCreateArgs<ExtArgs>>): Prisma__ReleaseProductChangeClient<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReleaseProductChanges.
     * @param {ReleaseProductChangeCreateManyArgs} args - Arguments to create many ReleaseProductChanges.
     * @example
     * // Create many ReleaseProductChanges
     * const releaseProductChange = await prisma.releaseProductChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReleaseProductChangeCreateManyArgs>(args?: SelectSubset<T, ReleaseProductChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReleaseProductChanges and returns the data saved in the database.
     * @param {ReleaseProductChangeCreateManyAndReturnArgs} args - Arguments to create many ReleaseProductChanges.
     * @example
     * // Create many ReleaseProductChanges
     * const releaseProductChange = await prisma.releaseProductChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReleaseProductChanges and only return the `id`
     * const releaseProductChangeWithIdOnly = await prisma.releaseProductChange.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReleaseProductChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, ReleaseProductChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReleaseProductChange.
     * @param {ReleaseProductChangeDeleteArgs} args - Arguments to delete one ReleaseProductChange.
     * @example
     * // Delete one ReleaseProductChange
     * const ReleaseProductChange = await prisma.releaseProductChange.delete({
     *   where: {
     *     // ... filter to delete one ReleaseProductChange
     *   }
     * })
     * 
     */
    delete<T extends ReleaseProductChangeDeleteArgs>(args: SelectSubset<T, ReleaseProductChangeDeleteArgs<ExtArgs>>): Prisma__ReleaseProductChangeClient<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReleaseProductChange.
     * @param {ReleaseProductChangeUpdateArgs} args - Arguments to update one ReleaseProductChange.
     * @example
     * // Update one ReleaseProductChange
     * const releaseProductChange = await prisma.releaseProductChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReleaseProductChangeUpdateArgs>(args: SelectSubset<T, ReleaseProductChangeUpdateArgs<ExtArgs>>): Prisma__ReleaseProductChangeClient<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReleaseProductChanges.
     * @param {ReleaseProductChangeDeleteManyArgs} args - Arguments to filter ReleaseProductChanges to delete.
     * @example
     * // Delete a few ReleaseProductChanges
     * const { count } = await prisma.releaseProductChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReleaseProductChangeDeleteManyArgs>(args?: SelectSubset<T, ReleaseProductChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReleaseProductChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReleaseProductChanges
     * const releaseProductChange = await prisma.releaseProductChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReleaseProductChangeUpdateManyArgs>(args: SelectSubset<T, ReleaseProductChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReleaseProductChange.
     * @param {ReleaseProductChangeUpsertArgs} args - Arguments to update or create a ReleaseProductChange.
     * @example
     * // Update or create a ReleaseProductChange
     * const releaseProductChange = await prisma.releaseProductChange.upsert({
     *   create: {
     *     // ... data to create a ReleaseProductChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReleaseProductChange we want to update
     *   }
     * })
     */
    upsert<T extends ReleaseProductChangeUpsertArgs>(args: SelectSubset<T, ReleaseProductChangeUpsertArgs<ExtArgs>>): Prisma__ReleaseProductChangeClient<$Result.GetResult<Prisma.$ReleaseProductChangePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReleaseProductChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductChangeCountArgs} args - Arguments to filter ReleaseProductChanges to count.
     * @example
     * // Count the number of ReleaseProductChanges
     * const count = await prisma.releaseProductChange.count({
     *   where: {
     *     // ... the filter for the ReleaseProductChanges we want to count
     *   }
     * })
    **/
    count<T extends ReleaseProductChangeCountArgs>(
      args?: Subset<T, ReleaseProductChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleaseProductChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReleaseProductChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleaseProductChangeAggregateArgs>(args: Subset<T, ReleaseProductChangeAggregateArgs>): Prisma.PrismaPromise<GetReleaseProductChangeAggregateType<T>>

    /**
     * Group by ReleaseProductChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseProductChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReleaseProductChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReleaseProductChangeGroupByArgs['orderBy'] }
        : { orderBy?: ReleaseProductChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReleaseProductChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseProductChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReleaseProductChange model
   */
  readonly fields: ReleaseProductChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReleaseProductChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReleaseProductChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    releaseProduct<T extends ReleaseProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReleaseProductDefaultArgs<ExtArgs>>): Prisma__ReleaseProductClient<$Result.GetResult<Prisma.$ReleaseProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReleaseProductChange model
   */ 
  interface ReleaseProductChangeFieldRefs {
    readonly id: FieldRef<"ReleaseProductChange", 'String'>
    readonly releaseProductId: FieldRef<"ReleaseProductChange", 'String'>
    readonly field: FieldRef<"ReleaseProductChange", 'String'>
    readonly oldValue: FieldRef<"ReleaseProductChange", 'String'>
    readonly newValue: FieldRef<"ReleaseProductChange", 'String'>
    readonly detectedAt: FieldRef<"ReleaseProductChange", 'DateTime'>
    readonly sourceUrl: FieldRef<"ReleaseProductChange", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReleaseProductChange findUnique
   */
  export type ReleaseProductChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProductChange to fetch.
     */
    where: ReleaseProductChangeWhereUniqueInput
  }

  /**
   * ReleaseProductChange findUniqueOrThrow
   */
  export type ReleaseProductChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProductChange to fetch.
     */
    where: ReleaseProductChangeWhereUniqueInput
  }

  /**
   * ReleaseProductChange findFirst
   */
  export type ReleaseProductChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProductChange to fetch.
     */
    where?: ReleaseProductChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleaseProductChanges to fetch.
     */
    orderBy?: ReleaseProductChangeOrderByWithRelationInput | ReleaseProductChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReleaseProductChanges.
     */
    cursor?: ReleaseProductChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleaseProductChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleaseProductChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReleaseProductChanges.
     */
    distinct?: ReleaseProductChangeScalarFieldEnum | ReleaseProductChangeScalarFieldEnum[]
  }

  /**
   * ReleaseProductChange findFirstOrThrow
   */
  export type ReleaseProductChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProductChange to fetch.
     */
    where?: ReleaseProductChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleaseProductChanges to fetch.
     */
    orderBy?: ReleaseProductChangeOrderByWithRelationInput | ReleaseProductChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReleaseProductChanges.
     */
    cursor?: ReleaseProductChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleaseProductChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleaseProductChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReleaseProductChanges.
     */
    distinct?: ReleaseProductChangeScalarFieldEnum | ReleaseProductChangeScalarFieldEnum[]
  }

  /**
   * ReleaseProductChange findMany
   */
  export type ReleaseProductChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseProductChanges to fetch.
     */
    where?: ReleaseProductChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleaseProductChanges to fetch.
     */
    orderBy?: ReleaseProductChangeOrderByWithRelationInput | ReleaseProductChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReleaseProductChanges.
     */
    cursor?: ReleaseProductChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleaseProductChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleaseProductChanges.
     */
    skip?: number
    distinct?: ReleaseProductChangeScalarFieldEnum | ReleaseProductChangeScalarFieldEnum[]
  }

  /**
   * ReleaseProductChange create
   */
  export type ReleaseProductChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a ReleaseProductChange.
     */
    data: XOR<ReleaseProductChangeCreateInput, ReleaseProductChangeUncheckedCreateInput>
  }

  /**
   * ReleaseProductChange createMany
   */
  export type ReleaseProductChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReleaseProductChanges.
     */
    data: ReleaseProductChangeCreateManyInput | ReleaseProductChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReleaseProductChange createManyAndReturn
   */
  export type ReleaseProductChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReleaseProductChanges.
     */
    data: ReleaseProductChangeCreateManyInput | ReleaseProductChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReleaseProductChange update
   */
  export type ReleaseProductChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a ReleaseProductChange.
     */
    data: XOR<ReleaseProductChangeUpdateInput, ReleaseProductChangeUncheckedUpdateInput>
    /**
     * Choose, which ReleaseProductChange to update.
     */
    where: ReleaseProductChangeWhereUniqueInput
  }

  /**
   * ReleaseProductChange updateMany
   */
  export type ReleaseProductChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReleaseProductChanges.
     */
    data: XOR<ReleaseProductChangeUpdateManyMutationInput, ReleaseProductChangeUncheckedUpdateManyInput>
    /**
     * Filter which ReleaseProductChanges to update
     */
    where?: ReleaseProductChangeWhereInput
  }

  /**
   * ReleaseProductChange upsert
   */
  export type ReleaseProductChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the ReleaseProductChange to update in case it exists.
     */
    where: ReleaseProductChangeWhereUniqueInput
    /**
     * In case the ReleaseProductChange found by the `where` argument doesn't exist, create a new ReleaseProductChange with this data.
     */
    create: XOR<ReleaseProductChangeCreateInput, ReleaseProductChangeUncheckedCreateInput>
    /**
     * In case the ReleaseProductChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReleaseProductChangeUpdateInput, ReleaseProductChangeUncheckedUpdateInput>
  }

  /**
   * ReleaseProductChange delete
   */
  export type ReleaseProductChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
    /**
     * Filter which ReleaseProductChange to delete.
     */
    where: ReleaseProductChangeWhereUniqueInput
  }

  /**
   * ReleaseProductChange deleteMany
   */
  export type ReleaseProductChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseProductChanges to delete
     */
    where?: ReleaseProductChangeWhereInput
  }

  /**
   * ReleaseProductChange without action
   */
  export type ReleaseProductChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseProductChange
     */
    select?: ReleaseProductChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseProductChangeInclude<ExtArgs> | null
  }


  /**
   * Model TrendingItem
   */

  export type AggregateTrendingItem = {
    _count: TrendingItemCountAggregateOutputType | null
    _avg: TrendingItemAvgAggregateOutputType | null
    _sum: TrendingItemSumAggregateOutputType | null
    _min: TrendingItemMinAggregateOutputType | null
    _max: TrendingItemMaxAggregateOutputType | null
  }

  export type TrendingItemAvgAggregateOutputType = {
    currentPrice: number | null
    priceChange24h: number | null
    priceChange7d: number | null
    priceChange30d: number | null
    volumeIncrease: number | null
    searchVolume: number | null
  }

  export type TrendingItemSumAggregateOutputType = {
    currentPrice: number | null
    priceChange24h: number | null
    priceChange7d: number | null
    priceChange30d: number | null
    volumeIncrease: number | null
    searchVolume: number | null
  }

  export type TrendingItemMinAggregateOutputType = {
    id: string | null
    cardName: string | null
    cardSet: string | null
    category: $Enums.Category | null
    currentPrice: number | null
    priceChange24h: number | null
    priceChange7d: number | null
    priceChange30d: number | null
    volumeIncrease: number | null
    searchVolume: number | null
    sentiment: string | null
    calculatedAt: Date | null
  }

  export type TrendingItemMaxAggregateOutputType = {
    id: string | null
    cardName: string | null
    cardSet: string | null
    category: $Enums.Category | null
    currentPrice: number | null
    priceChange24h: number | null
    priceChange7d: number | null
    priceChange30d: number | null
    volumeIncrease: number | null
    searchVolume: number | null
    sentiment: string | null
    calculatedAt: Date | null
  }

  export type TrendingItemCountAggregateOutputType = {
    id: number
    cardName: number
    cardSet: number
    category: number
    currentPrice: number
    priceChange24h: number
    priceChange7d: number
    priceChange30d: number
    volumeIncrease: number
    searchVolume: number
    sentiment: number
    calculatedAt: number
    _all: number
  }


  export type TrendingItemAvgAggregateInputType = {
    currentPrice?: true
    priceChange24h?: true
    priceChange7d?: true
    priceChange30d?: true
    volumeIncrease?: true
    searchVolume?: true
  }

  export type TrendingItemSumAggregateInputType = {
    currentPrice?: true
    priceChange24h?: true
    priceChange7d?: true
    priceChange30d?: true
    volumeIncrease?: true
    searchVolume?: true
  }

  export type TrendingItemMinAggregateInputType = {
    id?: true
    cardName?: true
    cardSet?: true
    category?: true
    currentPrice?: true
    priceChange24h?: true
    priceChange7d?: true
    priceChange30d?: true
    volumeIncrease?: true
    searchVolume?: true
    sentiment?: true
    calculatedAt?: true
  }

  export type TrendingItemMaxAggregateInputType = {
    id?: true
    cardName?: true
    cardSet?: true
    category?: true
    currentPrice?: true
    priceChange24h?: true
    priceChange7d?: true
    priceChange30d?: true
    volumeIncrease?: true
    searchVolume?: true
    sentiment?: true
    calculatedAt?: true
  }

  export type TrendingItemCountAggregateInputType = {
    id?: true
    cardName?: true
    cardSet?: true
    category?: true
    currentPrice?: true
    priceChange24h?: true
    priceChange7d?: true
    priceChange30d?: true
    volumeIncrease?: true
    searchVolume?: true
    sentiment?: true
    calculatedAt?: true
    _all?: true
  }

  export type TrendingItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrendingItem to aggregate.
     */
    where?: TrendingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendingItems to fetch.
     */
    orderBy?: TrendingItemOrderByWithRelationInput | TrendingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrendingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrendingItems
    **/
    _count?: true | TrendingItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrendingItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrendingItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrendingItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrendingItemMaxAggregateInputType
  }

  export type GetTrendingItemAggregateType<T extends TrendingItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTrendingItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrendingItem[P]>
      : GetScalarType<T[P], AggregateTrendingItem[P]>
  }




  export type TrendingItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrendingItemWhereInput
    orderBy?: TrendingItemOrderByWithAggregationInput | TrendingItemOrderByWithAggregationInput[]
    by: TrendingItemScalarFieldEnum[] | TrendingItemScalarFieldEnum
    having?: TrendingItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrendingItemCountAggregateInputType | true
    _avg?: TrendingItemAvgAggregateInputType
    _sum?: TrendingItemSumAggregateInputType
    _min?: TrendingItemMinAggregateInputType
    _max?: TrendingItemMaxAggregateInputType
  }

  export type TrendingItemGroupByOutputType = {
    id: string
    cardName: string
    cardSet: string
    category: $Enums.Category
    currentPrice: number
    priceChange24h: number
    priceChange7d: number
    priceChange30d: number
    volumeIncrease: number
    searchVolume: number
    sentiment: string
    calculatedAt: Date
    _count: TrendingItemCountAggregateOutputType | null
    _avg: TrendingItemAvgAggregateOutputType | null
    _sum: TrendingItemSumAggregateOutputType | null
    _min: TrendingItemMinAggregateOutputType | null
    _max: TrendingItemMaxAggregateOutputType | null
  }

  type GetTrendingItemGroupByPayload<T extends TrendingItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrendingItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrendingItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrendingItemGroupByOutputType[P]>
            : GetScalarType<T[P], TrendingItemGroupByOutputType[P]>
        }
      >
    >


  export type TrendingItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardName?: boolean
    cardSet?: boolean
    category?: boolean
    currentPrice?: boolean
    priceChange24h?: boolean
    priceChange7d?: boolean
    priceChange30d?: boolean
    volumeIncrease?: boolean
    searchVolume?: boolean
    sentiment?: boolean
    calculatedAt?: boolean
  }, ExtArgs["result"]["trendingItem"]>

  export type TrendingItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardName?: boolean
    cardSet?: boolean
    category?: boolean
    currentPrice?: boolean
    priceChange24h?: boolean
    priceChange7d?: boolean
    priceChange30d?: boolean
    volumeIncrease?: boolean
    searchVolume?: boolean
    sentiment?: boolean
    calculatedAt?: boolean
  }, ExtArgs["result"]["trendingItem"]>

  export type TrendingItemSelectScalar = {
    id?: boolean
    cardName?: boolean
    cardSet?: boolean
    category?: boolean
    currentPrice?: boolean
    priceChange24h?: boolean
    priceChange7d?: boolean
    priceChange30d?: boolean
    volumeIncrease?: boolean
    searchVolume?: boolean
    sentiment?: boolean
    calculatedAt?: boolean
  }


  export type $TrendingItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrendingItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cardName: string
      cardSet: string
      category: $Enums.Category
      currentPrice: number
      priceChange24h: number
      priceChange7d: number
      priceChange30d: number
      volumeIncrease: number
      searchVolume: number
      sentiment: string
      calculatedAt: Date
    }, ExtArgs["result"]["trendingItem"]>
    composites: {}
  }

  type TrendingItemGetPayload<S extends boolean | null | undefined | TrendingItemDefaultArgs> = $Result.GetResult<Prisma.$TrendingItemPayload, S>

  type TrendingItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrendingItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrendingItemCountAggregateInputType | true
    }

  export interface TrendingItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrendingItem'], meta: { name: 'TrendingItem' } }
    /**
     * Find zero or one TrendingItem that matches the filter.
     * @param {TrendingItemFindUniqueArgs} args - Arguments to find a TrendingItem
     * @example
     * // Get one TrendingItem
     * const trendingItem = await prisma.trendingItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrendingItemFindUniqueArgs>(args: SelectSubset<T, TrendingItemFindUniqueArgs<ExtArgs>>): Prisma__TrendingItemClient<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrendingItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrendingItemFindUniqueOrThrowArgs} args - Arguments to find a TrendingItem
     * @example
     * // Get one TrendingItem
     * const trendingItem = await prisma.trendingItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrendingItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TrendingItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrendingItemClient<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrendingItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingItemFindFirstArgs} args - Arguments to find a TrendingItem
     * @example
     * // Get one TrendingItem
     * const trendingItem = await prisma.trendingItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrendingItemFindFirstArgs>(args?: SelectSubset<T, TrendingItemFindFirstArgs<ExtArgs>>): Prisma__TrendingItemClient<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrendingItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingItemFindFirstOrThrowArgs} args - Arguments to find a TrendingItem
     * @example
     * // Get one TrendingItem
     * const trendingItem = await prisma.trendingItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrendingItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TrendingItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrendingItemClient<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrendingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrendingItems
     * const trendingItems = await prisma.trendingItem.findMany()
     * 
     * // Get first 10 TrendingItems
     * const trendingItems = await prisma.trendingItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trendingItemWithIdOnly = await prisma.trendingItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrendingItemFindManyArgs>(args?: SelectSubset<T, TrendingItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrendingItem.
     * @param {TrendingItemCreateArgs} args - Arguments to create a TrendingItem.
     * @example
     * // Create one TrendingItem
     * const TrendingItem = await prisma.trendingItem.create({
     *   data: {
     *     // ... data to create a TrendingItem
     *   }
     * })
     * 
     */
    create<T extends TrendingItemCreateArgs>(args: SelectSubset<T, TrendingItemCreateArgs<ExtArgs>>): Prisma__TrendingItemClient<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrendingItems.
     * @param {TrendingItemCreateManyArgs} args - Arguments to create many TrendingItems.
     * @example
     * // Create many TrendingItems
     * const trendingItem = await prisma.trendingItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrendingItemCreateManyArgs>(args?: SelectSubset<T, TrendingItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrendingItems and returns the data saved in the database.
     * @param {TrendingItemCreateManyAndReturnArgs} args - Arguments to create many TrendingItems.
     * @example
     * // Create many TrendingItems
     * const trendingItem = await prisma.trendingItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrendingItems and only return the `id`
     * const trendingItemWithIdOnly = await prisma.trendingItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrendingItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TrendingItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrendingItem.
     * @param {TrendingItemDeleteArgs} args - Arguments to delete one TrendingItem.
     * @example
     * // Delete one TrendingItem
     * const TrendingItem = await prisma.trendingItem.delete({
     *   where: {
     *     // ... filter to delete one TrendingItem
     *   }
     * })
     * 
     */
    delete<T extends TrendingItemDeleteArgs>(args: SelectSubset<T, TrendingItemDeleteArgs<ExtArgs>>): Prisma__TrendingItemClient<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrendingItem.
     * @param {TrendingItemUpdateArgs} args - Arguments to update one TrendingItem.
     * @example
     * // Update one TrendingItem
     * const trendingItem = await prisma.trendingItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrendingItemUpdateArgs>(args: SelectSubset<T, TrendingItemUpdateArgs<ExtArgs>>): Prisma__TrendingItemClient<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrendingItems.
     * @param {TrendingItemDeleteManyArgs} args - Arguments to filter TrendingItems to delete.
     * @example
     * // Delete a few TrendingItems
     * const { count } = await prisma.trendingItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrendingItemDeleteManyArgs>(args?: SelectSubset<T, TrendingItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrendingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrendingItems
     * const trendingItem = await prisma.trendingItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrendingItemUpdateManyArgs>(args: SelectSubset<T, TrendingItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrendingItem.
     * @param {TrendingItemUpsertArgs} args - Arguments to update or create a TrendingItem.
     * @example
     * // Update or create a TrendingItem
     * const trendingItem = await prisma.trendingItem.upsert({
     *   create: {
     *     // ... data to create a TrendingItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrendingItem we want to update
     *   }
     * })
     */
    upsert<T extends TrendingItemUpsertArgs>(args: SelectSubset<T, TrendingItemUpsertArgs<ExtArgs>>): Prisma__TrendingItemClient<$Result.GetResult<Prisma.$TrendingItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrendingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingItemCountArgs} args - Arguments to filter TrendingItems to count.
     * @example
     * // Count the number of TrendingItems
     * const count = await prisma.trendingItem.count({
     *   where: {
     *     // ... the filter for the TrendingItems we want to count
     *   }
     * })
    **/
    count<T extends TrendingItemCountArgs>(
      args?: Subset<T, TrendingItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrendingItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrendingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrendingItemAggregateArgs>(args: Subset<T, TrendingItemAggregateArgs>): Prisma.PrismaPromise<GetTrendingItemAggregateType<T>>

    /**
     * Group by TrendingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrendingItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrendingItemGroupByArgs['orderBy'] }
        : { orderBy?: TrendingItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrendingItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrendingItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrendingItem model
   */
  readonly fields: TrendingItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrendingItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrendingItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrendingItem model
   */ 
  interface TrendingItemFieldRefs {
    readonly id: FieldRef<"TrendingItem", 'String'>
    readonly cardName: FieldRef<"TrendingItem", 'String'>
    readonly cardSet: FieldRef<"TrendingItem", 'String'>
    readonly category: FieldRef<"TrendingItem", 'Category'>
    readonly currentPrice: FieldRef<"TrendingItem", 'Float'>
    readonly priceChange24h: FieldRef<"TrendingItem", 'Float'>
    readonly priceChange7d: FieldRef<"TrendingItem", 'Float'>
    readonly priceChange30d: FieldRef<"TrendingItem", 'Float'>
    readonly volumeIncrease: FieldRef<"TrendingItem", 'Float'>
    readonly searchVolume: FieldRef<"TrendingItem", 'Int'>
    readonly sentiment: FieldRef<"TrendingItem", 'String'>
    readonly calculatedAt: FieldRef<"TrendingItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrendingItem findUnique
   */
  export type TrendingItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
    /**
     * Filter, which TrendingItem to fetch.
     */
    where: TrendingItemWhereUniqueInput
  }

  /**
   * TrendingItem findUniqueOrThrow
   */
  export type TrendingItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
    /**
     * Filter, which TrendingItem to fetch.
     */
    where: TrendingItemWhereUniqueInput
  }

  /**
   * TrendingItem findFirst
   */
  export type TrendingItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
    /**
     * Filter, which TrendingItem to fetch.
     */
    where?: TrendingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendingItems to fetch.
     */
    orderBy?: TrendingItemOrderByWithRelationInput | TrendingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrendingItems.
     */
    cursor?: TrendingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrendingItems.
     */
    distinct?: TrendingItemScalarFieldEnum | TrendingItemScalarFieldEnum[]
  }

  /**
   * TrendingItem findFirstOrThrow
   */
  export type TrendingItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
    /**
     * Filter, which TrendingItem to fetch.
     */
    where?: TrendingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendingItems to fetch.
     */
    orderBy?: TrendingItemOrderByWithRelationInput | TrendingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrendingItems.
     */
    cursor?: TrendingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrendingItems.
     */
    distinct?: TrendingItemScalarFieldEnum | TrendingItemScalarFieldEnum[]
  }

  /**
   * TrendingItem findMany
   */
  export type TrendingItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
    /**
     * Filter, which TrendingItems to fetch.
     */
    where?: TrendingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendingItems to fetch.
     */
    orderBy?: TrendingItemOrderByWithRelationInput | TrendingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrendingItems.
     */
    cursor?: TrendingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendingItems.
     */
    skip?: number
    distinct?: TrendingItemScalarFieldEnum | TrendingItemScalarFieldEnum[]
  }

  /**
   * TrendingItem create
   */
  export type TrendingItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
    /**
     * The data needed to create a TrendingItem.
     */
    data: XOR<TrendingItemCreateInput, TrendingItemUncheckedCreateInput>
  }

  /**
   * TrendingItem createMany
   */
  export type TrendingItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrendingItems.
     */
    data: TrendingItemCreateManyInput | TrendingItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrendingItem createManyAndReturn
   */
  export type TrendingItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrendingItems.
     */
    data: TrendingItemCreateManyInput | TrendingItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrendingItem update
   */
  export type TrendingItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
    /**
     * The data needed to update a TrendingItem.
     */
    data: XOR<TrendingItemUpdateInput, TrendingItemUncheckedUpdateInput>
    /**
     * Choose, which TrendingItem to update.
     */
    where: TrendingItemWhereUniqueInput
  }

  /**
   * TrendingItem updateMany
   */
  export type TrendingItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrendingItems.
     */
    data: XOR<TrendingItemUpdateManyMutationInput, TrendingItemUncheckedUpdateManyInput>
    /**
     * Filter which TrendingItems to update
     */
    where?: TrendingItemWhereInput
  }

  /**
   * TrendingItem upsert
   */
  export type TrendingItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
    /**
     * The filter to search for the TrendingItem to update in case it exists.
     */
    where: TrendingItemWhereUniqueInput
    /**
     * In case the TrendingItem found by the `where` argument doesn't exist, create a new TrendingItem with this data.
     */
    create: XOR<TrendingItemCreateInput, TrendingItemUncheckedCreateInput>
    /**
     * In case the TrendingItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrendingItemUpdateInput, TrendingItemUncheckedUpdateInput>
  }

  /**
   * TrendingItem delete
   */
  export type TrendingItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
    /**
     * Filter which TrendingItem to delete.
     */
    where: TrendingItemWhereUniqueInput
  }

  /**
   * TrendingItem deleteMany
   */
  export type TrendingItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrendingItems to delete
     */
    where?: TrendingItemWhereInput
  }

  /**
   * TrendingItem without action
   */
  export type TrendingItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingItem
     */
    select?: TrendingItemSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    plan: 'plan',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    categories: 'categories',
    priceRangeMin: 'priceRangeMin',
    priceRangeMax: 'priceRangeMax',
    grades: 'grades',
    graders: 'graders',
    dealAlertThreshold: 'dealAlertThreshold',
    notificationChannels: 'notificationChannels'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const DealScalarFieldEnum: {
    id: 'id',
    cardName: 'cardName',
    cardSet: 'cardSet',
    year: 'year',
    cardNumber: 'cardNumber',
    variation: 'variation',
    grade: 'grade',
    grader: 'grader',
    marketPrice: 'marketPrice',
    dealPrice: 'dealPrice',
    savingsPercent: 'savingsPercent',
    savingsAmount: 'savingsAmount',
    marketplace: 'marketplace',
    sellerRating: 'sellerRating',
    sellerFeedback: 'sellerFeedback',
    listingUrl: 'listingUrl',
    imageUrl: 'imageUrl',
    category: 'category',
    liquidity: 'liquidity',
    lastSoldPrice: 'lastSoldPrice',
    thirtyDayAvg: 'thirtyDayAvg',
    ninetyDayTrend: 'ninetyDayTrend',
    popGraded: 'popGraded',
    popGrade10: 'popGrade10',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    strategy: 'strategy'
  };

  export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


  export const TrackedDealScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    createdAt: 'createdAt'
  };

  export type TrackedDealScalarFieldEnum = (typeof TrackedDealScalarFieldEnum)[keyof typeof TrackedDealScalarFieldEnum]


  export const PortfolioItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cardName: 'cardName',
    cardSet: 'cardSet',
    year: 'year',
    grade: 'grade',
    grader: 'grader',
    currentValue: 'currentValue',
    purchasePrice: 'purchasePrice',
    purchaseDate: 'purchaseDate',
    quantity: 'quantity',
    imageUrl: 'imageUrl',
    notes: 'notes',
    inGradingQueue: 'inGradingQueue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioItemScalarFieldEnum = (typeof PortfolioItemScalarFieldEnum)[keyof typeof PortfolioItemScalarFieldEnum]


  export const ReleaseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    releaseDate: 'releaseDate',
    category: 'category',
    manufacturer: 'manufacturer',
    msrp: 'msrp',
    estimatedResale: 'estimatedResale',
    hypeScore: 'hypeScore',
    imageUrl: 'imageUrl',
    topChases: 'topChases',
    printRun: 'printRun',
    description: 'description',
    isReleased: 'isReleased',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReleaseScalarFieldEnum = (typeof ReleaseScalarFieldEnum)[keyof typeof ReleaseScalarFieldEnum]


  export const ReleaseProductScalarFieldEnum: {
    id: 'id',
    releaseId: 'releaseId',
    name: 'name',
    productType: 'productType',
    category: 'category',
    msrp: 'msrp',
    estimatedResale: 'estimatedResale',
    releaseDate: 'releaseDate',
    preorderDate: 'preorderDate',
    imageUrl: 'imageUrl',
    buyUrl: 'buyUrl',
    contentsSummary: 'contentsSummary',
    sourceTier: 'sourceTier',
    sourceUrl: 'sourceUrl',
    confidence: 'confidence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReleaseProductScalarFieldEnum = (typeof ReleaseProductScalarFieldEnum)[keyof typeof ReleaseProductScalarFieldEnum]


  export const ReleaseProductChangeScalarFieldEnum: {
    id: 'id',
    releaseProductId: 'releaseProductId',
    field: 'field',
    oldValue: 'oldValue',
    newValue: 'newValue',
    detectedAt: 'detectedAt',
    sourceUrl: 'sourceUrl'
  };

  export type ReleaseProductChangeScalarFieldEnum = (typeof ReleaseProductChangeScalarFieldEnum)[keyof typeof ReleaseProductChangeScalarFieldEnum]


  export const TrendingItemScalarFieldEnum: {
    id: 'id',
    cardName: 'cardName',
    cardSet: 'cardSet',
    category: 'category',
    currentPrice: 'currentPrice',
    priceChange24h: 'priceChange24h',
    priceChange7d: 'priceChange7d',
    priceChange30d: 'priceChange30d',
    volumeIncrease: 'volumeIncrease',
    searchVolume: 'searchVolume',
    sentiment: 'sentiment',
    calculatedAt: 'calculatedAt'
  };

  export type TrendingItemScalarFieldEnum = (typeof TrendingItemScalarFieldEnum)[keyof typeof TrendingItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Plan'
   */
  export type EnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan'>
    


  /**
   * Reference to a field of type 'Plan[]'
   */
  export type ListEnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'Liquidity'
   */
  export type EnumLiquidityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Liquidity'>
    


  /**
   * Reference to a field of type 'Liquidity[]'
   */
  export type ListEnumLiquidityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Liquidity[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'SourceTier'
   */
  export type EnumSourceTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceTier'>
    


  /**
   * Reference to a field of type 'SourceTier[]'
   */
  export type ListEnumSourceTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceTier[]'>
    


  /**
   * Reference to a field of type 'Confidence'
   */
  export type EnumConfidenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Confidence'>
    


  /**
   * Reference to a field of type 'Confidence[]'
   */
  export type ListEnumConfidenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Confidence[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    plan?: EnumPlanFilter<"User"> | $Enums.Plan
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    preferences?: XOR<UserPreferencesNullableRelationFilter, UserPreferencesWhereInput> | null
    portfolio?: PortfolioItemListRelationFilter
    trackedDeals?: TrackedDealListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferences?: UserPreferencesOrderByWithRelationInput
    portfolio?: PortfolioItemOrderByRelationAggregateInput
    trackedDeals?: TrackedDealOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    plan?: EnumPlanFilter<"User"> | $Enums.Plan
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    preferences?: XOR<UserPreferencesNullableRelationFilter, UserPreferencesWhereInput> | null
    portfolio?: PortfolioItemListRelationFilter
    trackedDeals?: TrackedDealListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    plan?: EnumPlanWithAggregatesFilter<"User"> | $Enums.Plan
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: StringFilter<"UserPreferences"> | string
    userId?: StringFilter<"UserPreferences"> | string
    categories?: StringNullableListFilter<"UserPreferences">
    priceRangeMin?: FloatFilter<"UserPreferences"> | number
    priceRangeMax?: FloatFilter<"UserPreferences"> | number
    grades?: StringNullableListFilter<"UserPreferences">
    graders?: StringNullableListFilter<"UserPreferences">
    dealAlertThreshold?: FloatFilter<"UserPreferences"> | number
    notificationChannels?: StringNullableListFilter<"UserPreferences">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    categories?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    grades?: SortOrder
    graders?: SortOrder
    dealAlertThreshold?: SortOrder
    notificationChannels?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    categories?: StringNullableListFilter<"UserPreferences">
    priceRangeMin?: FloatFilter<"UserPreferences"> | number
    priceRangeMax?: FloatFilter<"UserPreferences"> | number
    grades?: StringNullableListFilter<"UserPreferences">
    graders?: StringNullableListFilter<"UserPreferences">
    dealAlertThreshold?: FloatFilter<"UserPreferences"> | number
    notificationChannels?: StringNullableListFilter<"UserPreferences">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    categories?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    grades?: SortOrder
    graders?: SortOrder
    dealAlertThreshold?: SortOrder
    notificationChannels?: SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _avg?: UserPreferencesAvgOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
    _sum?: UserPreferencesSumOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreferences"> | string
    userId?: StringWithAggregatesFilter<"UserPreferences"> | string
    categories?: StringNullableListFilter<"UserPreferences">
    priceRangeMin?: FloatWithAggregatesFilter<"UserPreferences"> | number
    priceRangeMax?: FloatWithAggregatesFilter<"UserPreferences"> | number
    grades?: StringNullableListFilter<"UserPreferences">
    graders?: StringNullableListFilter<"UserPreferences">
    dealAlertThreshold?: FloatWithAggregatesFilter<"UserPreferences"> | number
    notificationChannels?: StringNullableListFilter<"UserPreferences">
  }

  export type DealWhereInput = {
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    id?: StringFilter<"Deal"> | string
    cardName?: StringFilter<"Deal"> | string
    cardSet?: StringFilter<"Deal"> | string
    year?: IntFilter<"Deal"> | number
    cardNumber?: StringNullableFilter<"Deal"> | string | null
    variation?: StringNullableFilter<"Deal"> | string | null
    grade?: StringFilter<"Deal"> | string
    grader?: StringNullableFilter<"Deal"> | string | null
    marketPrice?: FloatFilter<"Deal"> | number
    dealPrice?: FloatFilter<"Deal"> | number
    savingsPercent?: FloatFilter<"Deal"> | number
    savingsAmount?: FloatFilter<"Deal"> | number
    marketplace?: StringFilter<"Deal"> | string
    sellerRating?: FloatFilter<"Deal"> | number
    sellerFeedback?: IntFilter<"Deal"> | number
    listingUrl?: StringFilter<"Deal"> | string
    imageUrl?: StringNullableFilter<"Deal"> | string | null
    category?: EnumCategoryFilter<"Deal"> | $Enums.Category
    liquidity?: EnumLiquidityFilter<"Deal"> | $Enums.Liquidity
    lastSoldPrice?: FloatNullableFilter<"Deal"> | number | null
    thirtyDayAvg?: FloatNullableFilter<"Deal"> | number | null
    ninetyDayTrend?: FloatNullableFilter<"Deal"> | number | null
    popGraded?: IntNullableFilter<"Deal"> | number | null
    popGrade10?: IntNullableFilter<"Deal"> | number | null
    isActive?: BoolFilter<"Deal"> | boolean
    expiresAt?: DateTimeNullableFilter<"Deal"> | Date | string | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    strategy?: JsonNullableFilter<"Deal">
    trackedBy?: TrackedDealListRelationFilter
  }

  export type DealOrderByWithRelationInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    cardNumber?: SortOrderInput | SortOrder
    variation?: SortOrderInput | SortOrder
    grade?: SortOrder
    grader?: SortOrderInput | SortOrder
    marketPrice?: SortOrder
    dealPrice?: SortOrder
    savingsPercent?: SortOrder
    savingsAmount?: SortOrder
    marketplace?: SortOrder
    sellerRating?: SortOrder
    sellerFeedback?: SortOrder
    listingUrl?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    liquidity?: SortOrder
    lastSoldPrice?: SortOrderInput | SortOrder
    thirtyDayAvg?: SortOrderInput | SortOrder
    ninetyDayTrend?: SortOrderInput | SortOrder
    popGraded?: SortOrderInput | SortOrder
    popGrade10?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    strategy?: SortOrderInput | SortOrder
    trackedBy?: TrackedDealOrderByRelationAggregateInput
  }

  export type DealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    cardName?: StringFilter<"Deal"> | string
    cardSet?: StringFilter<"Deal"> | string
    year?: IntFilter<"Deal"> | number
    cardNumber?: StringNullableFilter<"Deal"> | string | null
    variation?: StringNullableFilter<"Deal"> | string | null
    grade?: StringFilter<"Deal"> | string
    grader?: StringNullableFilter<"Deal"> | string | null
    marketPrice?: FloatFilter<"Deal"> | number
    dealPrice?: FloatFilter<"Deal"> | number
    savingsPercent?: FloatFilter<"Deal"> | number
    savingsAmount?: FloatFilter<"Deal"> | number
    marketplace?: StringFilter<"Deal"> | string
    sellerRating?: FloatFilter<"Deal"> | number
    sellerFeedback?: IntFilter<"Deal"> | number
    listingUrl?: StringFilter<"Deal"> | string
    imageUrl?: StringNullableFilter<"Deal"> | string | null
    category?: EnumCategoryFilter<"Deal"> | $Enums.Category
    liquidity?: EnumLiquidityFilter<"Deal"> | $Enums.Liquidity
    lastSoldPrice?: FloatNullableFilter<"Deal"> | number | null
    thirtyDayAvg?: FloatNullableFilter<"Deal"> | number | null
    ninetyDayTrend?: FloatNullableFilter<"Deal"> | number | null
    popGraded?: IntNullableFilter<"Deal"> | number | null
    popGrade10?: IntNullableFilter<"Deal"> | number | null
    isActive?: BoolFilter<"Deal"> | boolean
    expiresAt?: DateTimeNullableFilter<"Deal"> | Date | string | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    strategy?: JsonNullableFilter<"Deal">
    trackedBy?: TrackedDealListRelationFilter
  }, "id">

  export type DealOrderByWithAggregationInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    cardNumber?: SortOrderInput | SortOrder
    variation?: SortOrderInput | SortOrder
    grade?: SortOrder
    grader?: SortOrderInput | SortOrder
    marketPrice?: SortOrder
    dealPrice?: SortOrder
    savingsPercent?: SortOrder
    savingsAmount?: SortOrder
    marketplace?: SortOrder
    sellerRating?: SortOrder
    sellerFeedback?: SortOrder
    listingUrl?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    liquidity?: SortOrder
    lastSoldPrice?: SortOrderInput | SortOrder
    thirtyDayAvg?: SortOrderInput | SortOrder
    ninetyDayTrend?: SortOrderInput | SortOrder
    popGraded?: SortOrderInput | SortOrder
    popGrade10?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    strategy?: SortOrderInput | SortOrder
    _count?: DealCountOrderByAggregateInput
    _avg?: DealAvgOrderByAggregateInput
    _max?: DealMaxOrderByAggregateInput
    _min?: DealMinOrderByAggregateInput
    _sum?: DealSumOrderByAggregateInput
  }

  export type DealScalarWhereWithAggregatesInput = {
    AND?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    OR?: DealScalarWhereWithAggregatesInput[]
    NOT?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deal"> | string
    cardName?: StringWithAggregatesFilter<"Deal"> | string
    cardSet?: StringWithAggregatesFilter<"Deal"> | string
    year?: IntWithAggregatesFilter<"Deal"> | number
    cardNumber?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    variation?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    grade?: StringWithAggregatesFilter<"Deal"> | string
    grader?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    marketPrice?: FloatWithAggregatesFilter<"Deal"> | number
    dealPrice?: FloatWithAggregatesFilter<"Deal"> | number
    savingsPercent?: FloatWithAggregatesFilter<"Deal"> | number
    savingsAmount?: FloatWithAggregatesFilter<"Deal"> | number
    marketplace?: StringWithAggregatesFilter<"Deal"> | string
    sellerRating?: FloatWithAggregatesFilter<"Deal"> | number
    sellerFeedback?: IntWithAggregatesFilter<"Deal"> | number
    listingUrl?: StringWithAggregatesFilter<"Deal"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    category?: EnumCategoryWithAggregatesFilter<"Deal"> | $Enums.Category
    liquidity?: EnumLiquidityWithAggregatesFilter<"Deal"> | $Enums.Liquidity
    lastSoldPrice?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    thirtyDayAvg?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    ninetyDayTrend?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    popGraded?: IntNullableWithAggregatesFilter<"Deal"> | number | null
    popGrade10?: IntNullableWithAggregatesFilter<"Deal"> | number | null
    isActive?: BoolWithAggregatesFilter<"Deal"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Deal"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    strategy?: JsonNullableWithAggregatesFilter<"Deal">
  }

  export type TrackedDealWhereInput = {
    AND?: TrackedDealWhereInput | TrackedDealWhereInput[]
    OR?: TrackedDealWhereInput[]
    NOT?: TrackedDealWhereInput | TrackedDealWhereInput[]
    id?: StringFilter<"TrackedDeal"> | string
    userId?: StringFilter<"TrackedDeal"> | string
    dealId?: StringFilter<"TrackedDeal"> | string
    createdAt?: DateTimeFilter<"TrackedDeal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    deal?: XOR<DealRelationFilter, DealWhereInput>
  }

  export type TrackedDealOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
  }

  export type TrackedDealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_dealId?: TrackedDealUserIdDealIdCompoundUniqueInput
    AND?: TrackedDealWhereInput | TrackedDealWhereInput[]
    OR?: TrackedDealWhereInput[]
    NOT?: TrackedDealWhereInput | TrackedDealWhereInput[]
    userId?: StringFilter<"TrackedDeal"> | string
    dealId?: StringFilter<"TrackedDeal"> | string
    createdAt?: DateTimeFilter<"TrackedDeal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    deal?: XOR<DealRelationFilter, DealWhereInput>
  }, "id" | "userId_dealId">

  export type TrackedDealOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
    _count?: TrackedDealCountOrderByAggregateInput
    _max?: TrackedDealMaxOrderByAggregateInput
    _min?: TrackedDealMinOrderByAggregateInput
  }

  export type TrackedDealScalarWhereWithAggregatesInput = {
    AND?: TrackedDealScalarWhereWithAggregatesInput | TrackedDealScalarWhereWithAggregatesInput[]
    OR?: TrackedDealScalarWhereWithAggregatesInput[]
    NOT?: TrackedDealScalarWhereWithAggregatesInput | TrackedDealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrackedDeal"> | string
    userId?: StringWithAggregatesFilter<"TrackedDeal"> | string
    dealId?: StringWithAggregatesFilter<"TrackedDeal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrackedDeal"> | Date | string
  }

  export type PortfolioItemWhereInput = {
    AND?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    OR?: PortfolioItemWhereInput[]
    NOT?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    id?: StringFilter<"PortfolioItem"> | string
    userId?: StringFilter<"PortfolioItem"> | string
    cardName?: StringFilter<"PortfolioItem"> | string
    cardSet?: StringFilter<"PortfolioItem"> | string
    year?: IntFilter<"PortfolioItem"> | number
    grade?: StringFilter<"PortfolioItem"> | string
    grader?: StringNullableFilter<"PortfolioItem"> | string | null
    currentValue?: FloatFilter<"PortfolioItem"> | number
    purchasePrice?: FloatFilter<"PortfolioItem"> | number
    purchaseDate?: DateTimeFilter<"PortfolioItem"> | Date | string
    quantity?: IntFilter<"PortfolioItem"> | number
    imageUrl?: StringNullableFilter<"PortfolioItem"> | string | null
    notes?: StringNullableFilter<"PortfolioItem"> | string | null
    inGradingQueue?: BoolFilter<"PortfolioItem"> | boolean
    createdAt?: DateTimeFilter<"PortfolioItem"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PortfolioItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    grade?: SortOrder
    grader?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    purchasePrice?: SortOrder
    purchaseDate?: SortOrder
    quantity?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    inGradingQueue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PortfolioItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    OR?: PortfolioItemWhereInput[]
    NOT?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    userId?: StringFilter<"PortfolioItem"> | string
    cardName?: StringFilter<"PortfolioItem"> | string
    cardSet?: StringFilter<"PortfolioItem"> | string
    year?: IntFilter<"PortfolioItem"> | number
    grade?: StringFilter<"PortfolioItem"> | string
    grader?: StringNullableFilter<"PortfolioItem"> | string | null
    currentValue?: FloatFilter<"PortfolioItem"> | number
    purchasePrice?: FloatFilter<"PortfolioItem"> | number
    purchaseDate?: DateTimeFilter<"PortfolioItem"> | Date | string
    quantity?: IntFilter<"PortfolioItem"> | number
    imageUrl?: StringNullableFilter<"PortfolioItem"> | string | null
    notes?: StringNullableFilter<"PortfolioItem"> | string | null
    inGradingQueue?: BoolFilter<"PortfolioItem"> | boolean
    createdAt?: DateTimeFilter<"PortfolioItem"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PortfolioItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    grade?: SortOrder
    grader?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    purchasePrice?: SortOrder
    purchaseDate?: SortOrder
    quantity?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    inGradingQueue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioItemCountOrderByAggregateInput
    _avg?: PortfolioItemAvgOrderByAggregateInput
    _max?: PortfolioItemMaxOrderByAggregateInput
    _min?: PortfolioItemMinOrderByAggregateInput
    _sum?: PortfolioItemSumOrderByAggregateInput
  }

  export type PortfolioItemScalarWhereWithAggregatesInput = {
    AND?: PortfolioItemScalarWhereWithAggregatesInput | PortfolioItemScalarWhereWithAggregatesInput[]
    OR?: PortfolioItemScalarWhereWithAggregatesInput[]
    NOT?: PortfolioItemScalarWhereWithAggregatesInput | PortfolioItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PortfolioItem"> | string
    userId?: StringWithAggregatesFilter<"PortfolioItem"> | string
    cardName?: StringWithAggregatesFilter<"PortfolioItem"> | string
    cardSet?: StringWithAggregatesFilter<"PortfolioItem"> | string
    year?: IntWithAggregatesFilter<"PortfolioItem"> | number
    grade?: StringWithAggregatesFilter<"PortfolioItem"> | string
    grader?: StringNullableWithAggregatesFilter<"PortfolioItem"> | string | null
    currentValue?: FloatWithAggregatesFilter<"PortfolioItem"> | number
    purchasePrice?: FloatWithAggregatesFilter<"PortfolioItem"> | number
    purchaseDate?: DateTimeWithAggregatesFilter<"PortfolioItem"> | Date | string
    quantity?: IntWithAggregatesFilter<"PortfolioItem"> | number
    imageUrl?: StringNullableWithAggregatesFilter<"PortfolioItem"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PortfolioItem"> | string | null
    inGradingQueue?: BoolWithAggregatesFilter<"PortfolioItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PortfolioItem"> | Date | string
  }

  export type ReleaseWhereInput = {
    AND?: ReleaseWhereInput | ReleaseWhereInput[]
    OR?: ReleaseWhereInput[]
    NOT?: ReleaseWhereInput | ReleaseWhereInput[]
    id?: StringFilter<"Release"> | string
    name?: StringFilter<"Release"> | string
    releaseDate?: DateTimeFilter<"Release"> | Date | string
    category?: EnumCategoryFilter<"Release"> | $Enums.Category
    manufacturer?: StringFilter<"Release"> | string
    msrp?: FloatFilter<"Release"> | number
    estimatedResale?: FloatNullableFilter<"Release"> | number | null
    hypeScore?: FloatNullableFilter<"Release"> | number | null
    imageUrl?: StringNullableFilter<"Release"> | string | null
    topChases?: StringNullableListFilter<"Release">
    printRun?: StringNullableFilter<"Release"> | string | null
    description?: StringNullableFilter<"Release"> | string | null
    isReleased?: BoolFilter<"Release"> | boolean
    createdAt?: DateTimeFilter<"Release"> | Date | string
    updatedAt?: DateTimeFilter<"Release"> | Date | string
    products?: ReleaseProductListRelationFilter
  }

  export type ReleaseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    releaseDate?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    msrp?: SortOrder
    estimatedResale?: SortOrderInput | SortOrder
    hypeScore?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    topChases?: SortOrder
    printRun?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isReleased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ReleaseProductOrderByRelationAggregateInput
  }

  export type ReleaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReleaseWhereInput | ReleaseWhereInput[]
    OR?: ReleaseWhereInput[]
    NOT?: ReleaseWhereInput | ReleaseWhereInput[]
    name?: StringFilter<"Release"> | string
    releaseDate?: DateTimeFilter<"Release"> | Date | string
    category?: EnumCategoryFilter<"Release"> | $Enums.Category
    manufacturer?: StringFilter<"Release"> | string
    msrp?: FloatFilter<"Release"> | number
    estimatedResale?: FloatNullableFilter<"Release"> | number | null
    hypeScore?: FloatNullableFilter<"Release"> | number | null
    imageUrl?: StringNullableFilter<"Release"> | string | null
    topChases?: StringNullableListFilter<"Release">
    printRun?: StringNullableFilter<"Release"> | string | null
    description?: StringNullableFilter<"Release"> | string | null
    isReleased?: BoolFilter<"Release"> | boolean
    createdAt?: DateTimeFilter<"Release"> | Date | string
    updatedAt?: DateTimeFilter<"Release"> | Date | string
    products?: ReleaseProductListRelationFilter
  }, "id">

  export type ReleaseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    releaseDate?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    msrp?: SortOrder
    estimatedResale?: SortOrderInput | SortOrder
    hypeScore?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    topChases?: SortOrder
    printRun?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isReleased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReleaseCountOrderByAggregateInput
    _avg?: ReleaseAvgOrderByAggregateInput
    _max?: ReleaseMaxOrderByAggregateInput
    _min?: ReleaseMinOrderByAggregateInput
    _sum?: ReleaseSumOrderByAggregateInput
  }

  export type ReleaseScalarWhereWithAggregatesInput = {
    AND?: ReleaseScalarWhereWithAggregatesInput | ReleaseScalarWhereWithAggregatesInput[]
    OR?: ReleaseScalarWhereWithAggregatesInput[]
    NOT?: ReleaseScalarWhereWithAggregatesInput | ReleaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Release"> | string
    name?: StringWithAggregatesFilter<"Release"> | string
    releaseDate?: DateTimeWithAggregatesFilter<"Release"> | Date | string
    category?: EnumCategoryWithAggregatesFilter<"Release"> | $Enums.Category
    manufacturer?: StringWithAggregatesFilter<"Release"> | string
    msrp?: FloatWithAggregatesFilter<"Release"> | number
    estimatedResale?: FloatNullableWithAggregatesFilter<"Release"> | number | null
    hypeScore?: FloatNullableWithAggregatesFilter<"Release"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"Release"> | string | null
    topChases?: StringNullableListFilter<"Release">
    printRun?: StringNullableWithAggregatesFilter<"Release"> | string | null
    description?: StringNullableWithAggregatesFilter<"Release"> | string | null
    isReleased?: BoolWithAggregatesFilter<"Release"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Release"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Release"> | Date | string
  }

  export type ReleaseProductWhereInput = {
    AND?: ReleaseProductWhereInput | ReleaseProductWhereInput[]
    OR?: ReleaseProductWhereInput[]
    NOT?: ReleaseProductWhereInput | ReleaseProductWhereInput[]
    id?: StringFilter<"ReleaseProduct"> | string
    releaseId?: StringFilter<"ReleaseProduct"> | string
    name?: StringFilter<"ReleaseProduct"> | string
    productType?: StringFilter<"ReleaseProduct"> | string
    category?: EnumCategoryFilter<"ReleaseProduct"> | $Enums.Category
    msrp?: FloatNullableFilter<"ReleaseProduct"> | number | null
    estimatedResale?: FloatNullableFilter<"ReleaseProduct"> | number | null
    releaseDate?: DateTimeNullableFilter<"ReleaseProduct"> | Date | string | null
    preorderDate?: DateTimeNullableFilter<"ReleaseProduct"> | Date | string | null
    imageUrl?: StringNullableFilter<"ReleaseProduct"> | string | null
    buyUrl?: StringNullableFilter<"ReleaseProduct"> | string | null
    contentsSummary?: StringNullableFilter<"ReleaseProduct"> | string | null
    sourceTier?: EnumSourceTierNullableFilter<"ReleaseProduct"> | $Enums.SourceTier | null
    sourceUrl?: StringNullableFilter<"ReleaseProduct"> | string | null
    confidence?: EnumConfidenceFilter<"ReleaseProduct"> | $Enums.Confidence
    createdAt?: DateTimeFilter<"ReleaseProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ReleaseProduct"> | Date | string
    release?: XOR<ReleaseRelationFilter, ReleaseWhereInput>
    changes?: ReleaseProductChangeListRelationFilter
  }

  export type ReleaseProductOrderByWithRelationInput = {
    id?: SortOrder
    releaseId?: SortOrder
    name?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    msrp?: SortOrderInput | SortOrder
    estimatedResale?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    preorderDate?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    buyUrl?: SortOrderInput | SortOrder
    contentsSummary?: SortOrderInput | SortOrder
    sourceTier?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    release?: ReleaseOrderByWithRelationInput
    changes?: ReleaseProductChangeOrderByRelationAggregateInput
  }

  export type ReleaseProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReleaseProductWhereInput | ReleaseProductWhereInput[]
    OR?: ReleaseProductWhereInput[]
    NOT?: ReleaseProductWhereInput | ReleaseProductWhereInput[]
    releaseId?: StringFilter<"ReleaseProduct"> | string
    name?: StringFilter<"ReleaseProduct"> | string
    productType?: StringFilter<"ReleaseProduct"> | string
    category?: EnumCategoryFilter<"ReleaseProduct"> | $Enums.Category
    msrp?: FloatNullableFilter<"ReleaseProduct"> | number | null
    estimatedResale?: FloatNullableFilter<"ReleaseProduct"> | number | null
    releaseDate?: DateTimeNullableFilter<"ReleaseProduct"> | Date | string | null
    preorderDate?: DateTimeNullableFilter<"ReleaseProduct"> | Date | string | null
    imageUrl?: StringNullableFilter<"ReleaseProduct"> | string | null
    buyUrl?: StringNullableFilter<"ReleaseProduct"> | string | null
    contentsSummary?: StringNullableFilter<"ReleaseProduct"> | string | null
    sourceTier?: EnumSourceTierNullableFilter<"ReleaseProduct"> | $Enums.SourceTier | null
    sourceUrl?: StringNullableFilter<"ReleaseProduct"> | string | null
    confidence?: EnumConfidenceFilter<"ReleaseProduct"> | $Enums.Confidence
    createdAt?: DateTimeFilter<"ReleaseProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ReleaseProduct"> | Date | string
    release?: XOR<ReleaseRelationFilter, ReleaseWhereInput>
    changes?: ReleaseProductChangeListRelationFilter
  }, "id">

  export type ReleaseProductOrderByWithAggregationInput = {
    id?: SortOrder
    releaseId?: SortOrder
    name?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    msrp?: SortOrderInput | SortOrder
    estimatedResale?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    preorderDate?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    buyUrl?: SortOrderInput | SortOrder
    contentsSummary?: SortOrderInput | SortOrder
    sourceTier?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReleaseProductCountOrderByAggregateInput
    _avg?: ReleaseProductAvgOrderByAggregateInput
    _max?: ReleaseProductMaxOrderByAggregateInput
    _min?: ReleaseProductMinOrderByAggregateInput
    _sum?: ReleaseProductSumOrderByAggregateInput
  }

  export type ReleaseProductScalarWhereWithAggregatesInput = {
    AND?: ReleaseProductScalarWhereWithAggregatesInput | ReleaseProductScalarWhereWithAggregatesInput[]
    OR?: ReleaseProductScalarWhereWithAggregatesInput[]
    NOT?: ReleaseProductScalarWhereWithAggregatesInput | ReleaseProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReleaseProduct"> | string
    releaseId?: StringWithAggregatesFilter<"ReleaseProduct"> | string
    name?: StringWithAggregatesFilter<"ReleaseProduct"> | string
    productType?: StringWithAggregatesFilter<"ReleaseProduct"> | string
    category?: EnumCategoryWithAggregatesFilter<"ReleaseProduct"> | $Enums.Category
    msrp?: FloatNullableWithAggregatesFilter<"ReleaseProduct"> | number | null
    estimatedResale?: FloatNullableWithAggregatesFilter<"ReleaseProduct"> | number | null
    releaseDate?: DateTimeNullableWithAggregatesFilter<"ReleaseProduct"> | Date | string | null
    preorderDate?: DateTimeNullableWithAggregatesFilter<"ReleaseProduct"> | Date | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"ReleaseProduct"> | string | null
    buyUrl?: StringNullableWithAggregatesFilter<"ReleaseProduct"> | string | null
    contentsSummary?: StringNullableWithAggregatesFilter<"ReleaseProduct"> | string | null
    sourceTier?: EnumSourceTierNullableWithAggregatesFilter<"ReleaseProduct"> | $Enums.SourceTier | null
    sourceUrl?: StringNullableWithAggregatesFilter<"ReleaseProduct"> | string | null
    confidence?: EnumConfidenceWithAggregatesFilter<"ReleaseProduct"> | $Enums.Confidence
    createdAt?: DateTimeWithAggregatesFilter<"ReleaseProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReleaseProduct"> | Date | string
  }

  export type ReleaseProductChangeWhereInput = {
    AND?: ReleaseProductChangeWhereInput | ReleaseProductChangeWhereInput[]
    OR?: ReleaseProductChangeWhereInput[]
    NOT?: ReleaseProductChangeWhereInput | ReleaseProductChangeWhereInput[]
    id?: StringFilter<"ReleaseProductChange"> | string
    releaseProductId?: StringFilter<"ReleaseProductChange"> | string
    field?: StringFilter<"ReleaseProductChange"> | string
    oldValue?: StringNullableFilter<"ReleaseProductChange"> | string | null
    newValue?: StringNullableFilter<"ReleaseProductChange"> | string | null
    detectedAt?: DateTimeFilter<"ReleaseProductChange"> | Date | string
    sourceUrl?: StringNullableFilter<"ReleaseProductChange"> | string | null
    releaseProduct?: XOR<ReleaseProductRelationFilter, ReleaseProductWhereInput>
  }

  export type ReleaseProductChangeOrderByWithRelationInput = {
    id?: SortOrder
    releaseProductId?: SortOrder
    field?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    detectedAt?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    releaseProduct?: ReleaseProductOrderByWithRelationInput
  }

  export type ReleaseProductChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReleaseProductChangeWhereInput | ReleaseProductChangeWhereInput[]
    OR?: ReleaseProductChangeWhereInput[]
    NOT?: ReleaseProductChangeWhereInput | ReleaseProductChangeWhereInput[]
    releaseProductId?: StringFilter<"ReleaseProductChange"> | string
    field?: StringFilter<"ReleaseProductChange"> | string
    oldValue?: StringNullableFilter<"ReleaseProductChange"> | string | null
    newValue?: StringNullableFilter<"ReleaseProductChange"> | string | null
    detectedAt?: DateTimeFilter<"ReleaseProductChange"> | Date | string
    sourceUrl?: StringNullableFilter<"ReleaseProductChange"> | string | null
    releaseProduct?: XOR<ReleaseProductRelationFilter, ReleaseProductWhereInput>
  }, "id">

  export type ReleaseProductChangeOrderByWithAggregationInput = {
    id?: SortOrder
    releaseProductId?: SortOrder
    field?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    detectedAt?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    _count?: ReleaseProductChangeCountOrderByAggregateInput
    _max?: ReleaseProductChangeMaxOrderByAggregateInput
    _min?: ReleaseProductChangeMinOrderByAggregateInput
  }

  export type ReleaseProductChangeScalarWhereWithAggregatesInput = {
    AND?: ReleaseProductChangeScalarWhereWithAggregatesInput | ReleaseProductChangeScalarWhereWithAggregatesInput[]
    OR?: ReleaseProductChangeScalarWhereWithAggregatesInput[]
    NOT?: ReleaseProductChangeScalarWhereWithAggregatesInput | ReleaseProductChangeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReleaseProductChange"> | string
    releaseProductId?: StringWithAggregatesFilter<"ReleaseProductChange"> | string
    field?: StringWithAggregatesFilter<"ReleaseProductChange"> | string
    oldValue?: StringNullableWithAggregatesFilter<"ReleaseProductChange"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"ReleaseProductChange"> | string | null
    detectedAt?: DateTimeWithAggregatesFilter<"ReleaseProductChange"> | Date | string
    sourceUrl?: StringNullableWithAggregatesFilter<"ReleaseProductChange"> | string | null
  }

  export type TrendingItemWhereInput = {
    AND?: TrendingItemWhereInput | TrendingItemWhereInput[]
    OR?: TrendingItemWhereInput[]
    NOT?: TrendingItemWhereInput | TrendingItemWhereInput[]
    id?: StringFilter<"TrendingItem"> | string
    cardName?: StringFilter<"TrendingItem"> | string
    cardSet?: StringFilter<"TrendingItem"> | string
    category?: EnumCategoryFilter<"TrendingItem"> | $Enums.Category
    currentPrice?: FloatFilter<"TrendingItem"> | number
    priceChange24h?: FloatFilter<"TrendingItem"> | number
    priceChange7d?: FloatFilter<"TrendingItem"> | number
    priceChange30d?: FloatFilter<"TrendingItem"> | number
    volumeIncrease?: FloatFilter<"TrendingItem"> | number
    searchVolume?: IntFilter<"TrendingItem"> | number
    sentiment?: StringFilter<"TrendingItem"> | string
    calculatedAt?: DateTimeFilter<"TrendingItem"> | Date | string
  }

  export type TrendingItemOrderByWithRelationInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    category?: SortOrder
    currentPrice?: SortOrder
    priceChange24h?: SortOrder
    priceChange7d?: SortOrder
    priceChange30d?: SortOrder
    volumeIncrease?: SortOrder
    searchVolume?: SortOrder
    sentiment?: SortOrder
    calculatedAt?: SortOrder
  }

  export type TrendingItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrendingItemWhereInput | TrendingItemWhereInput[]
    OR?: TrendingItemWhereInput[]
    NOT?: TrendingItemWhereInput | TrendingItemWhereInput[]
    cardName?: StringFilter<"TrendingItem"> | string
    cardSet?: StringFilter<"TrendingItem"> | string
    category?: EnumCategoryFilter<"TrendingItem"> | $Enums.Category
    currentPrice?: FloatFilter<"TrendingItem"> | number
    priceChange24h?: FloatFilter<"TrendingItem"> | number
    priceChange7d?: FloatFilter<"TrendingItem"> | number
    priceChange30d?: FloatFilter<"TrendingItem"> | number
    volumeIncrease?: FloatFilter<"TrendingItem"> | number
    searchVolume?: IntFilter<"TrendingItem"> | number
    sentiment?: StringFilter<"TrendingItem"> | string
    calculatedAt?: DateTimeFilter<"TrendingItem"> | Date | string
  }, "id">

  export type TrendingItemOrderByWithAggregationInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    category?: SortOrder
    currentPrice?: SortOrder
    priceChange24h?: SortOrder
    priceChange7d?: SortOrder
    priceChange30d?: SortOrder
    volumeIncrease?: SortOrder
    searchVolume?: SortOrder
    sentiment?: SortOrder
    calculatedAt?: SortOrder
    _count?: TrendingItemCountOrderByAggregateInput
    _avg?: TrendingItemAvgOrderByAggregateInput
    _max?: TrendingItemMaxOrderByAggregateInput
    _min?: TrendingItemMinOrderByAggregateInput
    _sum?: TrendingItemSumOrderByAggregateInput
  }

  export type TrendingItemScalarWhereWithAggregatesInput = {
    AND?: TrendingItemScalarWhereWithAggregatesInput | TrendingItemScalarWhereWithAggregatesInput[]
    OR?: TrendingItemScalarWhereWithAggregatesInput[]
    NOT?: TrendingItemScalarWhereWithAggregatesInput | TrendingItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrendingItem"> | string
    cardName?: StringWithAggregatesFilter<"TrendingItem"> | string
    cardSet?: StringWithAggregatesFilter<"TrendingItem"> | string
    category?: EnumCategoryWithAggregatesFilter<"TrendingItem"> | $Enums.Category
    currentPrice?: FloatWithAggregatesFilter<"TrendingItem"> | number
    priceChange24h?: FloatWithAggregatesFilter<"TrendingItem"> | number
    priceChange7d?: FloatWithAggregatesFilter<"TrendingItem"> | number
    priceChange30d?: FloatWithAggregatesFilter<"TrendingItem"> | number
    volumeIncrease?: FloatWithAggregatesFilter<"TrendingItem"> | number
    searchVolume?: IntWithAggregatesFilter<"TrendingItem"> | number
    sentiment?: StringWithAggregatesFilter<"TrendingItem"> | string
    calculatedAt?: DateTimeWithAggregatesFilter<"TrendingItem"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    plan?: $Enums.Plan
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    portfolio?: PortfolioItemCreateNestedManyWithoutUserInput
    trackedDeals?: TrackedDealCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    plan?: $Enums.Plan
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutUserInput
    trackedDeals?: TrackedDealUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutUserNestedInput
    trackedDeals?: TrackedDealUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutUserNestedInput
    trackedDeals?: TrackedDealUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    plan?: $Enums.Plan
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateInput = {
    id?: string
    categories?: UserPreferencesCreatecategoriesInput | string[]
    priceRangeMin?: number
    priceRangeMax?: number
    grades?: UserPreferencesCreategradesInput | string[]
    graders?: UserPreferencesCreategradersInput | string[]
    dealAlertThreshold?: number
    notificationChannels?: UserPreferencesCreatenotificationChannelsInput | string[]
    user: UserCreateNestedOneWithoutPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    categories?: UserPreferencesCreatecategoriesInput | string[]
    priceRangeMin?: number
    priceRangeMax?: number
    grades?: UserPreferencesCreategradesInput | string[]
    graders?: UserPreferencesCreategradersInput | string[]
    dealAlertThreshold?: number
    notificationChannels?: UserPreferencesCreatenotificationChannelsInput | string[]
  }

  export type UserPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categories?: UserPreferencesUpdatecategoriesInput | string[]
    priceRangeMin?: FloatFieldUpdateOperationsInput | number
    priceRangeMax?: FloatFieldUpdateOperationsInput | number
    grades?: UserPreferencesUpdategradesInput | string[]
    graders?: UserPreferencesUpdategradersInput | string[]
    dealAlertThreshold?: FloatFieldUpdateOperationsInput | number
    notificationChannels?: UserPreferencesUpdatenotificationChannelsInput | string[]
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categories?: UserPreferencesUpdatecategoriesInput | string[]
    priceRangeMin?: FloatFieldUpdateOperationsInput | number
    priceRangeMax?: FloatFieldUpdateOperationsInput | number
    grades?: UserPreferencesUpdategradesInput | string[]
    graders?: UserPreferencesUpdategradersInput | string[]
    dealAlertThreshold?: FloatFieldUpdateOperationsInput | number
    notificationChannels?: UserPreferencesUpdatenotificationChannelsInput | string[]
  }

  export type UserPreferencesCreateManyInput = {
    id?: string
    userId: string
    categories?: UserPreferencesCreatecategoriesInput | string[]
    priceRangeMin?: number
    priceRangeMax?: number
    grades?: UserPreferencesCreategradesInput | string[]
    graders?: UserPreferencesCreategradersInput | string[]
    dealAlertThreshold?: number
    notificationChannels?: UserPreferencesCreatenotificationChannelsInput | string[]
  }

  export type UserPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    categories?: UserPreferencesUpdatecategoriesInput | string[]
    priceRangeMin?: FloatFieldUpdateOperationsInput | number
    priceRangeMax?: FloatFieldUpdateOperationsInput | number
    grades?: UserPreferencesUpdategradesInput | string[]
    graders?: UserPreferencesUpdategradersInput | string[]
    dealAlertThreshold?: FloatFieldUpdateOperationsInput | number
    notificationChannels?: UserPreferencesUpdatenotificationChannelsInput | string[]
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categories?: UserPreferencesUpdatecategoriesInput | string[]
    priceRangeMin?: FloatFieldUpdateOperationsInput | number
    priceRangeMax?: FloatFieldUpdateOperationsInput | number
    grades?: UserPreferencesUpdategradesInput | string[]
    graders?: UserPreferencesUpdategradersInput | string[]
    dealAlertThreshold?: FloatFieldUpdateOperationsInput | number
    notificationChannels?: UserPreferencesUpdatenotificationChannelsInput | string[]
  }

  export type DealCreateInput = {
    id?: string
    cardName: string
    cardSet: string
    year: number
    cardNumber?: string | null
    variation?: string | null
    grade: string
    grader?: string | null
    marketPrice: number
    dealPrice: number
    savingsPercent: number
    savingsAmount: number
    marketplace: string
    sellerRating: number
    sellerFeedback: number
    listingUrl: string
    imageUrl?: string | null
    category: $Enums.Category
    liquidity: $Enums.Liquidity
    lastSoldPrice?: number | null
    thirtyDayAvg?: number | null
    ninetyDayTrend?: number | null
    popGraded?: number | null
    popGrade10?: number | null
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
    trackedBy?: TrackedDealCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateInput = {
    id?: string
    cardName: string
    cardSet: string
    year: number
    cardNumber?: string | null
    variation?: string | null
    grade: string
    grader?: string | null
    marketPrice: number
    dealPrice: number
    savingsPercent: number
    savingsAmount: number
    marketplace: string
    sellerRating: number
    sellerFeedback: number
    listingUrl: string
    imageUrl?: string | null
    category: $Enums.Category
    liquidity: $Enums.Liquidity
    lastSoldPrice?: number | null
    thirtyDayAvg?: number | null
    ninetyDayTrend?: number | null
    popGraded?: number | null
    popGrade10?: number | null
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
    trackedBy?: TrackedDealUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    marketPrice?: FloatFieldUpdateOperationsInput | number
    dealPrice?: FloatFieldUpdateOperationsInput | number
    savingsPercent?: FloatFieldUpdateOperationsInput | number
    savingsAmount?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    sellerRating?: FloatFieldUpdateOperationsInput | number
    sellerFeedback?: IntFieldUpdateOperationsInput | number
    listingUrl?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    liquidity?: EnumLiquidityFieldUpdateOperationsInput | $Enums.Liquidity
    lastSoldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    thirtyDayAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ninetyDayTrend?: NullableFloatFieldUpdateOperationsInput | number | null
    popGraded?: NullableIntFieldUpdateOperationsInput | number | null
    popGrade10?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
    trackedBy?: TrackedDealUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    marketPrice?: FloatFieldUpdateOperationsInput | number
    dealPrice?: FloatFieldUpdateOperationsInput | number
    savingsPercent?: FloatFieldUpdateOperationsInput | number
    savingsAmount?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    sellerRating?: FloatFieldUpdateOperationsInput | number
    sellerFeedback?: IntFieldUpdateOperationsInput | number
    listingUrl?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    liquidity?: EnumLiquidityFieldUpdateOperationsInput | $Enums.Liquidity
    lastSoldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    thirtyDayAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ninetyDayTrend?: NullableFloatFieldUpdateOperationsInput | number | null
    popGraded?: NullableIntFieldUpdateOperationsInput | number | null
    popGrade10?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
    trackedBy?: TrackedDealUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealCreateManyInput = {
    id?: string
    cardName: string
    cardSet: string
    year: number
    cardNumber?: string | null
    variation?: string | null
    grade: string
    grader?: string | null
    marketPrice: number
    dealPrice: number
    savingsPercent: number
    savingsAmount: number
    marketplace: string
    sellerRating: number
    sellerFeedback: number
    listingUrl: string
    imageUrl?: string | null
    category: $Enums.Category
    liquidity: $Enums.Liquidity
    lastSoldPrice?: number | null
    thirtyDayAvg?: number | null
    ninetyDayTrend?: number | null
    popGraded?: number | null
    popGrade10?: number | null
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    marketPrice?: FloatFieldUpdateOperationsInput | number
    dealPrice?: FloatFieldUpdateOperationsInput | number
    savingsPercent?: FloatFieldUpdateOperationsInput | number
    savingsAmount?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    sellerRating?: FloatFieldUpdateOperationsInput | number
    sellerFeedback?: IntFieldUpdateOperationsInput | number
    listingUrl?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    liquidity?: EnumLiquidityFieldUpdateOperationsInput | $Enums.Liquidity
    lastSoldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    thirtyDayAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ninetyDayTrend?: NullableFloatFieldUpdateOperationsInput | number | null
    popGraded?: NullableIntFieldUpdateOperationsInput | number | null
    popGrade10?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    marketPrice?: FloatFieldUpdateOperationsInput | number
    dealPrice?: FloatFieldUpdateOperationsInput | number
    savingsPercent?: FloatFieldUpdateOperationsInput | number
    savingsAmount?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    sellerRating?: FloatFieldUpdateOperationsInput | number
    sellerFeedback?: IntFieldUpdateOperationsInput | number
    listingUrl?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    liquidity?: EnumLiquidityFieldUpdateOperationsInput | $Enums.Liquidity
    lastSoldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    thirtyDayAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ninetyDayTrend?: NullableFloatFieldUpdateOperationsInput | number | null
    popGraded?: NullableIntFieldUpdateOperationsInput | number | null
    popGrade10?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TrackedDealCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackedDealsInput
    deal: DealCreateNestedOneWithoutTrackedByInput
  }

  export type TrackedDealUncheckedCreateInput = {
    id?: string
    userId: string
    dealId: string
    createdAt?: Date | string
  }

  export type TrackedDealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackedDealsNestedInput
    deal?: DealUpdateOneRequiredWithoutTrackedByNestedInput
  }

  export type TrackedDealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackedDealCreateManyInput = {
    id?: string
    userId: string
    dealId: string
    createdAt?: Date | string
  }

  export type TrackedDealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackedDealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemCreateInput = {
    id?: string
    cardName: string
    cardSet: string
    year: number
    grade: string
    grader?: string | null
    currentValue: number
    purchasePrice: number
    purchaseDate?: Date | string
    quantity?: number
    imageUrl?: string | null
    notes?: string | null
    inGradingQueue?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPortfolioInput
  }

  export type PortfolioItemUncheckedCreateInput = {
    id?: string
    userId: string
    cardName: string
    cardSet: string
    year: number
    grade: string
    grader?: string | null
    currentValue: number
    purchasePrice: number
    purchaseDate?: Date | string
    quantity?: number
    imageUrl?: string | null
    notes?: string | null
    inGradingQueue?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    inGradingQueue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPortfolioNestedInput
  }

  export type PortfolioItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    inGradingQueue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemCreateManyInput = {
    id?: string
    userId: string
    cardName: string
    cardSet: string
    year: number
    grade: string
    grader?: string | null
    currentValue: number
    purchasePrice: number
    purchaseDate?: Date | string
    quantity?: number
    imageUrl?: string | null
    notes?: string | null
    inGradingQueue?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    inGradingQueue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    inGradingQueue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseCreateInput = {
    id?: string
    name: string
    releaseDate: Date | string
    category: $Enums.Category
    manufacturer: string
    msrp: number
    estimatedResale?: number | null
    hypeScore?: number | null
    imageUrl?: string | null
    topChases?: ReleaseCreatetopChasesInput | string[]
    printRun?: string | null
    description?: string | null
    isReleased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ReleaseProductCreateNestedManyWithoutReleaseInput
  }

  export type ReleaseUncheckedCreateInput = {
    id?: string
    name: string
    releaseDate: Date | string
    category: $Enums.Category
    manufacturer: string
    msrp: number
    estimatedResale?: number | null
    hypeScore?: number | null
    imageUrl?: string | null
    topChases?: ReleaseCreatetopChasesInput | string[]
    printRun?: string | null
    description?: string | null
    isReleased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ReleaseProductUncheckedCreateNestedManyWithoutReleaseInput
  }

  export type ReleaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    manufacturer?: StringFieldUpdateOperationsInput | string
    msrp?: FloatFieldUpdateOperationsInput | number
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    hypeScore?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topChases?: ReleaseUpdatetopChasesInput | string[]
    printRun?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isReleased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ReleaseProductUpdateManyWithoutReleaseNestedInput
  }

  export type ReleaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    manufacturer?: StringFieldUpdateOperationsInput | string
    msrp?: FloatFieldUpdateOperationsInput | number
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    hypeScore?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topChases?: ReleaseUpdatetopChasesInput | string[]
    printRun?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isReleased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ReleaseProductUncheckedUpdateManyWithoutReleaseNestedInput
  }

  export type ReleaseCreateManyInput = {
    id?: string
    name: string
    releaseDate: Date | string
    category: $Enums.Category
    manufacturer: string
    msrp: number
    estimatedResale?: number | null
    hypeScore?: number | null
    imageUrl?: string | null
    topChases?: ReleaseCreatetopChasesInput | string[]
    printRun?: string | null
    description?: string | null
    isReleased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    manufacturer?: StringFieldUpdateOperationsInput | string
    msrp?: FloatFieldUpdateOperationsInput | number
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    hypeScore?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topChases?: ReleaseUpdatetopChasesInput | string[]
    printRun?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isReleased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    manufacturer?: StringFieldUpdateOperationsInput | string
    msrp?: FloatFieldUpdateOperationsInput | number
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    hypeScore?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topChases?: ReleaseUpdatetopChasesInput | string[]
    printRun?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isReleased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseProductCreateInput = {
    id?: string
    name: string
    productType: string
    category: $Enums.Category
    msrp?: number | null
    estimatedResale?: number | null
    releaseDate?: Date | string | null
    preorderDate?: Date | string | null
    imageUrl?: string | null
    buyUrl?: string | null
    contentsSummary?: string | null
    sourceTier?: $Enums.SourceTier | null
    sourceUrl?: string | null
    confidence?: $Enums.Confidence
    createdAt?: Date | string
    updatedAt?: Date | string
    release: ReleaseCreateNestedOneWithoutProductsInput
    changes?: ReleaseProductChangeCreateNestedManyWithoutReleaseProductInput
  }

  export type ReleaseProductUncheckedCreateInput = {
    id?: string
    releaseId: string
    name: string
    productType: string
    category: $Enums.Category
    msrp?: number | null
    estimatedResale?: number | null
    releaseDate?: Date | string | null
    preorderDate?: Date | string | null
    imageUrl?: string | null
    buyUrl?: string | null
    contentsSummary?: string | null
    sourceTier?: $Enums.SourceTier | null
    sourceUrl?: string | null
    confidence?: $Enums.Confidence
    createdAt?: Date | string
    updatedAt?: Date | string
    changes?: ReleaseProductChangeUncheckedCreateNestedManyWithoutReleaseProductInput
  }

  export type ReleaseProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    msrp?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preorderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contentsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTier?: NullableEnumSourceTierFieldUpdateOperationsInput | $Enums.SourceTier | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: EnumConfidenceFieldUpdateOperationsInput | $Enums.Confidence
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    release?: ReleaseUpdateOneRequiredWithoutProductsNestedInput
    changes?: ReleaseProductChangeUpdateManyWithoutReleaseProductNestedInput
  }

  export type ReleaseProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    msrp?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preorderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contentsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTier?: NullableEnumSourceTierFieldUpdateOperationsInput | $Enums.SourceTier | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: EnumConfidenceFieldUpdateOperationsInput | $Enums.Confidence
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: ReleaseProductChangeUncheckedUpdateManyWithoutReleaseProductNestedInput
  }

  export type ReleaseProductCreateManyInput = {
    id?: string
    releaseId: string
    name: string
    productType: string
    category: $Enums.Category
    msrp?: number | null
    estimatedResale?: number | null
    releaseDate?: Date | string | null
    preorderDate?: Date | string | null
    imageUrl?: string | null
    buyUrl?: string | null
    contentsSummary?: string | null
    sourceTier?: $Enums.SourceTier | null
    sourceUrl?: string | null
    confidence?: $Enums.Confidence
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    msrp?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preorderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contentsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTier?: NullableEnumSourceTierFieldUpdateOperationsInput | $Enums.SourceTier | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: EnumConfidenceFieldUpdateOperationsInput | $Enums.Confidence
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    msrp?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preorderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contentsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTier?: NullableEnumSourceTierFieldUpdateOperationsInput | $Enums.SourceTier | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: EnumConfidenceFieldUpdateOperationsInput | $Enums.Confidence
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseProductChangeCreateInput = {
    id?: string
    field: string
    oldValue?: string | null
    newValue?: string | null
    detectedAt?: Date | string
    sourceUrl?: string | null
    releaseProduct: ReleaseProductCreateNestedOneWithoutChangesInput
  }

  export type ReleaseProductChangeUncheckedCreateInput = {
    id?: string
    releaseProductId: string
    field: string
    oldValue?: string | null
    newValue?: string | null
    detectedAt?: Date | string
    sourceUrl?: string | null
  }

  export type ReleaseProductChangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseProduct?: ReleaseProductUpdateOneRequiredWithoutChangesNestedInput
  }

  export type ReleaseProductChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseProductId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReleaseProductChangeCreateManyInput = {
    id?: string
    releaseProductId: string
    field: string
    oldValue?: string | null
    newValue?: string | null
    detectedAt?: Date | string
    sourceUrl?: string | null
  }

  export type ReleaseProductChangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReleaseProductChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseProductId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrendingItemCreateInput = {
    id?: string
    cardName: string
    cardSet: string
    category: $Enums.Category
    currentPrice: number
    priceChange24h?: number
    priceChange7d?: number
    priceChange30d?: number
    volumeIncrease?: number
    searchVolume?: number
    sentiment?: string
    calculatedAt?: Date | string
  }

  export type TrendingItemUncheckedCreateInput = {
    id?: string
    cardName: string
    cardSet: string
    category: $Enums.Category
    currentPrice: number
    priceChange24h?: number
    priceChange7d?: number
    priceChange30d?: number
    volumeIncrease?: number
    searchVolume?: number
    sentiment?: string
    calculatedAt?: Date | string
  }

  export type TrendingItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    currentPrice?: FloatFieldUpdateOperationsInput | number
    priceChange24h?: FloatFieldUpdateOperationsInput | number
    priceChange7d?: FloatFieldUpdateOperationsInput | number
    priceChange30d?: FloatFieldUpdateOperationsInput | number
    volumeIncrease?: FloatFieldUpdateOperationsInput | number
    searchVolume?: IntFieldUpdateOperationsInput | number
    sentiment?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendingItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    currentPrice?: FloatFieldUpdateOperationsInput | number
    priceChange24h?: FloatFieldUpdateOperationsInput | number
    priceChange7d?: FloatFieldUpdateOperationsInput | number
    priceChange30d?: FloatFieldUpdateOperationsInput | number
    volumeIncrease?: FloatFieldUpdateOperationsInput | number
    searchVolume?: IntFieldUpdateOperationsInput | number
    sentiment?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendingItemCreateManyInput = {
    id?: string
    cardName: string
    cardSet: string
    category: $Enums.Category
    currentPrice: number
    priceChange24h?: number
    priceChange7d?: number
    priceChange30d?: number
    volumeIncrease?: number
    searchVolume?: number
    sentiment?: string
    calculatedAt?: Date | string
  }

  export type TrendingItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    currentPrice?: FloatFieldUpdateOperationsInput | number
    priceChange24h?: FloatFieldUpdateOperationsInput | number
    priceChange7d?: FloatFieldUpdateOperationsInput | number
    priceChange30d?: FloatFieldUpdateOperationsInput | number
    volumeIncrease?: FloatFieldUpdateOperationsInput | number
    searchVolume?: IntFieldUpdateOperationsInput | number
    sentiment?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendingItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    currentPrice?: FloatFieldUpdateOperationsInput | number
    priceChange24h?: FloatFieldUpdateOperationsInput | number
    priceChange7d?: FloatFieldUpdateOperationsInput | number
    priceChange30d?: FloatFieldUpdateOperationsInput | number
    volumeIncrease?: FloatFieldUpdateOperationsInput | number
    searchVolume?: IntFieldUpdateOperationsInput | number
    sentiment?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanFilter<$PrismaModel> | $Enums.Plan
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserPreferencesNullableRelationFilter = {
    is?: UserPreferencesWhereInput | null
    isNot?: UserPreferencesWhereInput | null
  }

  export type PortfolioItemListRelationFilter = {
    every?: PortfolioItemWhereInput
    some?: PortfolioItemWhereInput
    none?: PortfolioItemWhereInput
  }

  export type TrackedDealListRelationFilter = {
    every?: TrackedDealWhereInput
    some?: TrackedDealWhereInput
    none?: TrackedDealWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PortfolioItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrackedDealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanWithAggregatesFilter<$PrismaModel> | $Enums.Plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanFilter<$PrismaModel>
    _max?: NestedEnumPlanFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categories?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    grades?: SortOrder
    graders?: SortOrder
    dealAlertThreshold?: SortOrder
    notificationChannels?: SortOrder
  }

  export type UserPreferencesAvgOrderByAggregateInput = {
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    dealAlertThreshold?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    dealAlertThreshold?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    dealAlertThreshold?: SortOrder
  }

  export type UserPreferencesSumOrderByAggregateInput = {
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    dealAlertThreshold?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type EnumLiquidityFilter<$PrismaModel = never> = {
    equals?: $Enums.Liquidity | EnumLiquidityFieldRefInput<$PrismaModel>
    in?: $Enums.Liquidity[] | ListEnumLiquidityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Liquidity[] | ListEnumLiquidityFieldRefInput<$PrismaModel>
    not?: NestedEnumLiquidityFilter<$PrismaModel> | $Enums.Liquidity
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DealCountOrderByAggregateInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    cardNumber?: SortOrder
    variation?: SortOrder
    grade?: SortOrder
    grader?: SortOrder
    marketPrice?: SortOrder
    dealPrice?: SortOrder
    savingsPercent?: SortOrder
    savingsAmount?: SortOrder
    marketplace?: SortOrder
    sellerRating?: SortOrder
    sellerFeedback?: SortOrder
    listingUrl?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    liquidity?: SortOrder
    lastSoldPrice?: SortOrder
    thirtyDayAvg?: SortOrder
    ninetyDayTrend?: SortOrder
    popGraded?: SortOrder
    popGrade10?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    strategy?: SortOrder
  }

  export type DealAvgOrderByAggregateInput = {
    year?: SortOrder
    marketPrice?: SortOrder
    dealPrice?: SortOrder
    savingsPercent?: SortOrder
    savingsAmount?: SortOrder
    sellerRating?: SortOrder
    sellerFeedback?: SortOrder
    lastSoldPrice?: SortOrder
    thirtyDayAvg?: SortOrder
    ninetyDayTrend?: SortOrder
    popGraded?: SortOrder
    popGrade10?: SortOrder
  }

  export type DealMaxOrderByAggregateInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    cardNumber?: SortOrder
    variation?: SortOrder
    grade?: SortOrder
    grader?: SortOrder
    marketPrice?: SortOrder
    dealPrice?: SortOrder
    savingsPercent?: SortOrder
    savingsAmount?: SortOrder
    marketplace?: SortOrder
    sellerRating?: SortOrder
    sellerFeedback?: SortOrder
    listingUrl?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    liquidity?: SortOrder
    lastSoldPrice?: SortOrder
    thirtyDayAvg?: SortOrder
    ninetyDayTrend?: SortOrder
    popGraded?: SortOrder
    popGrade10?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealMinOrderByAggregateInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    cardNumber?: SortOrder
    variation?: SortOrder
    grade?: SortOrder
    grader?: SortOrder
    marketPrice?: SortOrder
    dealPrice?: SortOrder
    savingsPercent?: SortOrder
    savingsAmount?: SortOrder
    marketplace?: SortOrder
    sellerRating?: SortOrder
    sellerFeedback?: SortOrder
    listingUrl?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    liquidity?: SortOrder
    lastSoldPrice?: SortOrder
    thirtyDayAvg?: SortOrder
    ninetyDayTrend?: SortOrder
    popGraded?: SortOrder
    popGrade10?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealSumOrderByAggregateInput = {
    year?: SortOrder
    marketPrice?: SortOrder
    dealPrice?: SortOrder
    savingsPercent?: SortOrder
    savingsAmount?: SortOrder
    sellerRating?: SortOrder
    sellerFeedback?: SortOrder
    lastSoldPrice?: SortOrder
    thirtyDayAvg?: SortOrder
    ninetyDayTrend?: SortOrder
    popGraded?: SortOrder
    popGrade10?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type EnumLiquidityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Liquidity | EnumLiquidityFieldRefInput<$PrismaModel>
    in?: $Enums.Liquidity[] | ListEnumLiquidityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Liquidity[] | ListEnumLiquidityFieldRefInput<$PrismaModel>
    not?: NestedEnumLiquidityWithAggregatesFilter<$PrismaModel> | $Enums.Liquidity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLiquidityFilter<$PrismaModel>
    _max?: NestedEnumLiquidityFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DealRelationFilter = {
    is?: DealWhereInput
    isNot?: DealWhereInput
  }

  export type TrackedDealUserIdDealIdCompoundUniqueInput = {
    userId: string
    dealId: string
  }

  export type TrackedDealCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackedDealMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackedDealMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
  }

  export type PortfolioItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    grade?: SortOrder
    grader?: SortOrder
    currentValue?: SortOrder
    purchasePrice?: SortOrder
    purchaseDate?: SortOrder
    quantity?: SortOrder
    imageUrl?: SortOrder
    notes?: SortOrder
    inGradingQueue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioItemAvgOrderByAggregateInput = {
    year?: SortOrder
    currentValue?: SortOrder
    purchasePrice?: SortOrder
    quantity?: SortOrder
  }

  export type PortfolioItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    grade?: SortOrder
    grader?: SortOrder
    currentValue?: SortOrder
    purchasePrice?: SortOrder
    purchaseDate?: SortOrder
    quantity?: SortOrder
    imageUrl?: SortOrder
    notes?: SortOrder
    inGradingQueue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    year?: SortOrder
    grade?: SortOrder
    grader?: SortOrder
    currentValue?: SortOrder
    purchasePrice?: SortOrder
    purchaseDate?: SortOrder
    quantity?: SortOrder
    imageUrl?: SortOrder
    notes?: SortOrder
    inGradingQueue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioItemSumOrderByAggregateInput = {
    year?: SortOrder
    currentValue?: SortOrder
    purchasePrice?: SortOrder
    quantity?: SortOrder
  }

  export type ReleaseProductListRelationFilter = {
    every?: ReleaseProductWhereInput
    some?: ReleaseProductWhereInput
    none?: ReleaseProductWhereInput
  }

  export type ReleaseProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReleaseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    releaseDate?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    msrp?: SortOrder
    estimatedResale?: SortOrder
    hypeScore?: SortOrder
    imageUrl?: SortOrder
    topChases?: SortOrder
    printRun?: SortOrder
    description?: SortOrder
    isReleased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseAvgOrderByAggregateInput = {
    msrp?: SortOrder
    estimatedResale?: SortOrder
    hypeScore?: SortOrder
  }

  export type ReleaseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    releaseDate?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    msrp?: SortOrder
    estimatedResale?: SortOrder
    hypeScore?: SortOrder
    imageUrl?: SortOrder
    printRun?: SortOrder
    description?: SortOrder
    isReleased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    releaseDate?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    msrp?: SortOrder
    estimatedResale?: SortOrder
    hypeScore?: SortOrder
    imageUrl?: SortOrder
    printRun?: SortOrder
    description?: SortOrder
    isReleased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseSumOrderByAggregateInput = {
    msrp?: SortOrder
    estimatedResale?: SortOrder
    hypeScore?: SortOrder
  }

  export type EnumSourceTierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceTier | EnumSourceTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.SourceTier[] | ListEnumSourceTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SourceTier[] | ListEnumSourceTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSourceTierNullableFilter<$PrismaModel> | $Enums.SourceTier | null
  }

  export type EnumConfidenceFilter<$PrismaModel = never> = {
    equals?: $Enums.Confidence | EnumConfidenceFieldRefInput<$PrismaModel>
    in?: $Enums.Confidence[] | ListEnumConfidenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Confidence[] | ListEnumConfidenceFieldRefInput<$PrismaModel>
    not?: NestedEnumConfidenceFilter<$PrismaModel> | $Enums.Confidence
  }

  export type ReleaseRelationFilter = {
    is?: ReleaseWhereInput
    isNot?: ReleaseWhereInput
  }

  export type ReleaseProductChangeListRelationFilter = {
    every?: ReleaseProductChangeWhereInput
    some?: ReleaseProductChangeWhereInput
    none?: ReleaseProductChangeWhereInput
  }

  export type ReleaseProductChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReleaseProductCountOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    name?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    msrp?: SortOrder
    estimatedResale?: SortOrder
    releaseDate?: SortOrder
    preorderDate?: SortOrder
    imageUrl?: SortOrder
    buyUrl?: SortOrder
    contentsSummary?: SortOrder
    sourceTier?: SortOrder
    sourceUrl?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseProductAvgOrderByAggregateInput = {
    msrp?: SortOrder
    estimatedResale?: SortOrder
  }

  export type ReleaseProductMaxOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    name?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    msrp?: SortOrder
    estimatedResale?: SortOrder
    releaseDate?: SortOrder
    preorderDate?: SortOrder
    imageUrl?: SortOrder
    buyUrl?: SortOrder
    contentsSummary?: SortOrder
    sourceTier?: SortOrder
    sourceUrl?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseProductMinOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    name?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    msrp?: SortOrder
    estimatedResale?: SortOrder
    releaseDate?: SortOrder
    preorderDate?: SortOrder
    imageUrl?: SortOrder
    buyUrl?: SortOrder
    contentsSummary?: SortOrder
    sourceTier?: SortOrder
    sourceUrl?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseProductSumOrderByAggregateInput = {
    msrp?: SortOrder
    estimatedResale?: SortOrder
  }

  export type EnumSourceTierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceTier | EnumSourceTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.SourceTier[] | ListEnumSourceTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SourceTier[] | ListEnumSourceTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSourceTierNullableWithAggregatesFilter<$PrismaModel> | $Enums.SourceTier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSourceTierNullableFilter<$PrismaModel>
    _max?: NestedEnumSourceTierNullableFilter<$PrismaModel>
  }

  export type EnumConfidenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Confidence | EnumConfidenceFieldRefInput<$PrismaModel>
    in?: $Enums.Confidence[] | ListEnumConfidenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Confidence[] | ListEnumConfidenceFieldRefInput<$PrismaModel>
    not?: NestedEnumConfidenceWithAggregatesFilter<$PrismaModel> | $Enums.Confidence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfidenceFilter<$PrismaModel>
    _max?: NestedEnumConfidenceFilter<$PrismaModel>
  }

  export type ReleaseProductRelationFilter = {
    is?: ReleaseProductWhereInput
    isNot?: ReleaseProductWhereInput
  }

  export type ReleaseProductChangeCountOrderByAggregateInput = {
    id?: SortOrder
    releaseProductId?: SortOrder
    field?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    detectedAt?: SortOrder
    sourceUrl?: SortOrder
  }

  export type ReleaseProductChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    releaseProductId?: SortOrder
    field?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    detectedAt?: SortOrder
    sourceUrl?: SortOrder
  }

  export type ReleaseProductChangeMinOrderByAggregateInput = {
    id?: SortOrder
    releaseProductId?: SortOrder
    field?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    detectedAt?: SortOrder
    sourceUrl?: SortOrder
  }

  export type TrendingItemCountOrderByAggregateInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    category?: SortOrder
    currentPrice?: SortOrder
    priceChange24h?: SortOrder
    priceChange7d?: SortOrder
    priceChange30d?: SortOrder
    volumeIncrease?: SortOrder
    searchVolume?: SortOrder
    sentiment?: SortOrder
    calculatedAt?: SortOrder
  }

  export type TrendingItemAvgOrderByAggregateInput = {
    currentPrice?: SortOrder
    priceChange24h?: SortOrder
    priceChange7d?: SortOrder
    priceChange30d?: SortOrder
    volumeIncrease?: SortOrder
    searchVolume?: SortOrder
  }

  export type TrendingItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    category?: SortOrder
    currentPrice?: SortOrder
    priceChange24h?: SortOrder
    priceChange7d?: SortOrder
    priceChange30d?: SortOrder
    volumeIncrease?: SortOrder
    searchVolume?: SortOrder
    sentiment?: SortOrder
    calculatedAt?: SortOrder
  }

  export type TrendingItemMinOrderByAggregateInput = {
    id?: SortOrder
    cardName?: SortOrder
    cardSet?: SortOrder
    category?: SortOrder
    currentPrice?: SortOrder
    priceChange24h?: SortOrder
    priceChange7d?: SortOrder
    priceChange30d?: SortOrder
    volumeIncrease?: SortOrder
    searchVolume?: SortOrder
    sentiment?: SortOrder
    calculatedAt?: SortOrder
  }

  export type TrendingItemSumOrderByAggregateInput = {
    currentPrice?: SortOrder
    priceChange24h?: SortOrder
    priceChange7d?: SortOrder
    priceChange30d?: SortOrder
    volumeIncrease?: SortOrder
    searchVolume?: SortOrder
  }

  export type UserPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type PortfolioItemCreateNestedManyWithoutUserInput = {
    create?: XOR<PortfolioItemCreateWithoutUserInput, PortfolioItemUncheckedCreateWithoutUserInput> | PortfolioItemCreateWithoutUserInput[] | PortfolioItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutUserInput | PortfolioItemCreateOrConnectWithoutUserInput[]
    createMany?: PortfolioItemCreateManyUserInputEnvelope
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
  }

  export type TrackedDealCreateNestedManyWithoutUserInput = {
    create?: XOR<TrackedDealCreateWithoutUserInput, TrackedDealUncheckedCreateWithoutUserInput> | TrackedDealCreateWithoutUserInput[] | TrackedDealUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrackedDealCreateOrConnectWithoutUserInput | TrackedDealCreateOrConnectWithoutUserInput[]
    createMany?: TrackedDealCreateManyUserInputEnvelope
    connect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
  }

  export type UserPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type PortfolioItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PortfolioItemCreateWithoutUserInput, PortfolioItemUncheckedCreateWithoutUserInput> | PortfolioItemCreateWithoutUserInput[] | PortfolioItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutUserInput | PortfolioItemCreateOrConnectWithoutUserInput[]
    createMany?: PortfolioItemCreateManyUserInputEnvelope
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
  }

  export type TrackedDealUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrackedDealCreateWithoutUserInput, TrackedDealUncheckedCreateWithoutUserInput> | TrackedDealCreateWithoutUserInput[] | TrackedDealUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrackedDealCreateOrConnectWithoutUserInput | TrackedDealCreateOrConnectWithoutUserInput[]
    createMany?: TrackedDealCreateManyUserInputEnvelope
    connect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumPlanFieldUpdateOperationsInput = {
    set?: $Enums.Plan
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type PortfolioItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<PortfolioItemCreateWithoutUserInput, PortfolioItemUncheckedCreateWithoutUserInput> | PortfolioItemCreateWithoutUserInput[] | PortfolioItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutUserInput | PortfolioItemCreateOrConnectWithoutUserInput[]
    upsert?: PortfolioItemUpsertWithWhereUniqueWithoutUserInput | PortfolioItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PortfolioItemCreateManyUserInputEnvelope
    set?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    disconnect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    delete?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    update?: PortfolioItemUpdateWithWhereUniqueWithoutUserInput | PortfolioItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PortfolioItemUpdateManyWithWhereWithoutUserInput | PortfolioItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
  }

  export type TrackedDealUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrackedDealCreateWithoutUserInput, TrackedDealUncheckedCreateWithoutUserInput> | TrackedDealCreateWithoutUserInput[] | TrackedDealUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrackedDealCreateOrConnectWithoutUserInput | TrackedDealCreateOrConnectWithoutUserInput[]
    upsert?: TrackedDealUpsertWithWhereUniqueWithoutUserInput | TrackedDealUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrackedDealCreateManyUserInputEnvelope
    set?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    disconnect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    delete?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    connect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    update?: TrackedDealUpdateWithWhereUniqueWithoutUserInput | TrackedDealUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrackedDealUpdateManyWithWhereWithoutUserInput | TrackedDealUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrackedDealScalarWhereInput | TrackedDealScalarWhereInput[]
  }

  export type UserPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type PortfolioItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PortfolioItemCreateWithoutUserInput, PortfolioItemUncheckedCreateWithoutUserInput> | PortfolioItemCreateWithoutUserInput[] | PortfolioItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutUserInput | PortfolioItemCreateOrConnectWithoutUserInput[]
    upsert?: PortfolioItemUpsertWithWhereUniqueWithoutUserInput | PortfolioItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PortfolioItemCreateManyUserInputEnvelope
    set?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    disconnect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    delete?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    update?: PortfolioItemUpdateWithWhereUniqueWithoutUserInput | PortfolioItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PortfolioItemUpdateManyWithWhereWithoutUserInput | PortfolioItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
  }

  export type TrackedDealUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrackedDealCreateWithoutUserInput, TrackedDealUncheckedCreateWithoutUserInput> | TrackedDealCreateWithoutUserInput[] | TrackedDealUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrackedDealCreateOrConnectWithoutUserInput | TrackedDealCreateOrConnectWithoutUserInput[]
    upsert?: TrackedDealUpsertWithWhereUniqueWithoutUserInput | TrackedDealUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrackedDealCreateManyUserInputEnvelope
    set?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    disconnect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    delete?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    connect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    update?: TrackedDealUpdateWithWhereUniqueWithoutUserInput | TrackedDealUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrackedDealUpdateManyWithWhereWithoutUserInput | TrackedDealUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrackedDealScalarWhereInput | TrackedDealScalarWhereInput[]
  }

  export type UserPreferencesCreatecategoriesInput = {
    set: string[]
  }

  export type UserPreferencesCreategradesInput = {
    set: string[]
  }

  export type UserPreferencesCreategradersInput = {
    set: string[]
  }

  export type UserPreferencesCreatenotificationChannelsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserPreferencesUpdatecategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserPreferencesUpdategradesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserPreferencesUpdategradersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserPreferencesUpdatenotificationChannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type TrackedDealCreateNestedManyWithoutDealInput = {
    create?: XOR<TrackedDealCreateWithoutDealInput, TrackedDealUncheckedCreateWithoutDealInput> | TrackedDealCreateWithoutDealInput[] | TrackedDealUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TrackedDealCreateOrConnectWithoutDealInput | TrackedDealCreateOrConnectWithoutDealInput[]
    createMany?: TrackedDealCreateManyDealInputEnvelope
    connect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
  }

  export type TrackedDealUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<TrackedDealCreateWithoutDealInput, TrackedDealUncheckedCreateWithoutDealInput> | TrackedDealCreateWithoutDealInput[] | TrackedDealUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TrackedDealCreateOrConnectWithoutDealInput | TrackedDealCreateOrConnectWithoutDealInput[]
    createMany?: TrackedDealCreateManyDealInputEnvelope
    connect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category
  }

  export type EnumLiquidityFieldUpdateOperationsInput = {
    set?: $Enums.Liquidity
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TrackedDealUpdateManyWithoutDealNestedInput = {
    create?: XOR<TrackedDealCreateWithoutDealInput, TrackedDealUncheckedCreateWithoutDealInput> | TrackedDealCreateWithoutDealInput[] | TrackedDealUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TrackedDealCreateOrConnectWithoutDealInput | TrackedDealCreateOrConnectWithoutDealInput[]
    upsert?: TrackedDealUpsertWithWhereUniqueWithoutDealInput | TrackedDealUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: TrackedDealCreateManyDealInputEnvelope
    set?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    disconnect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    delete?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    connect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    update?: TrackedDealUpdateWithWhereUniqueWithoutDealInput | TrackedDealUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: TrackedDealUpdateManyWithWhereWithoutDealInput | TrackedDealUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: TrackedDealScalarWhereInput | TrackedDealScalarWhereInput[]
  }

  export type TrackedDealUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<TrackedDealCreateWithoutDealInput, TrackedDealUncheckedCreateWithoutDealInput> | TrackedDealCreateWithoutDealInput[] | TrackedDealUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TrackedDealCreateOrConnectWithoutDealInput | TrackedDealCreateOrConnectWithoutDealInput[]
    upsert?: TrackedDealUpsertWithWhereUniqueWithoutDealInput | TrackedDealUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: TrackedDealCreateManyDealInputEnvelope
    set?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    disconnect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    delete?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    connect?: TrackedDealWhereUniqueInput | TrackedDealWhereUniqueInput[]
    update?: TrackedDealUpdateWithWhereUniqueWithoutDealInput | TrackedDealUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: TrackedDealUpdateManyWithWhereWithoutDealInput | TrackedDealUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: TrackedDealScalarWhereInput | TrackedDealScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTrackedDealsInput = {
    create?: XOR<UserCreateWithoutTrackedDealsInput, UserUncheckedCreateWithoutTrackedDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrackedDealsInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutTrackedByInput = {
    create?: XOR<DealCreateWithoutTrackedByInput, DealUncheckedCreateWithoutTrackedByInput>
    connectOrCreate?: DealCreateOrConnectWithoutTrackedByInput
    connect?: DealWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTrackedDealsNestedInput = {
    create?: XOR<UserCreateWithoutTrackedDealsInput, UserUncheckedCreateWithoutTrackedDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrackedDealsInput
    upsert?: UserUpsertWithoutTrackedDealsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrackedDealsInput, UserUpdateWithoutTrackedDealsInput>, UserUncheckedUpdateWithoutTrackedDealsInput>
  }

  export type DealUpdateOneRequiredWithoutTrackedByNestedInput = {
    create?: XOR<DealCreateWithoutTrackedByInput, DealUncheckedCreateWithoutTrackedByInput>
    connectOrCreate?: DealCreateOrConnectWithoutTrackedByInput
    upsert?: DealUpsertWithoutTrackedByInput
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutTrackedByInput, DealUpdateWithoutTrackedByInput>, DealUncheckedUpdateWithoutTrackedByInput>
  }

  export type UserCreateNestedOneWithoutPortfolioInput = {
    create?: XOR<UserCreateWithoutPortfolioInput, UserUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortfolioInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPortfolioNestedInput = {
    create?: XOR<UserCreateWithoutPortfolioInput, UserUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortfolioInput
    upsert?: UserUpsertWithoutPortfolioInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPortfolioInput, UserUpdateWithoutPortfolioInput>, UserUncheckedUpdateWithoutPortfolioInput>
  }

  export type ReleaseCreatetopChasesInput = {
    set: string[]
  }

  export type ReleaseProductCreateNestedManyWithoutReleaseInput = {
    create?: XOR<ReleaseProductCreateWithoutReleaseInput, ReleaseProductUncheckedCreateWithoutReleaseInput> | ReleaseProductCreateWithoutReleaseInput[] | ReleaseProductUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseProductCreateOrConnectWithoutReleaseInput | ReleaseProductCreateOrConnectWithoutReleaseInput[]
    createMany?: ReleaseProductCreateManyReleaseInputEnvelope
    connect?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
  }

  export type ReleaseProductUncheckedCreateNestedManyWithoutReleaseInput = {
    create?: XOR<ReleaseProductCreateWithoutReleaseInput, ReleaseProductUncheckedCreateWithoutReleaseInput> | ReleaseProductCreateWithoutReleaseInput[] | ReleaseProductUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseProductCreateOrConnectWithoutReleaseInput | ReleaseProductCreateOrConnectWithoutReleaseInput[]
    createMany?: ReleaseProductCreateManyReleaseInputEnvelope
    connect?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
  }

  export type ReleaseUpdatetopChasesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ReleaseProductUpdateManyWithoutReleaseNestedInput = {
    create?: XOR<ReleaseProductCreateWithoutReleaseInput, ReleaseProductUncheckedCreateWithoutReleaseInput> | ReleaseProductCreateWithoutReleaseInput[] | ReleaseProductUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseProductCreateOrConnectWithoutReleaseInput | ReleaseProductCreateOrConnectWithoutReleaseInput[]
    upsert?: ReleaseProductUpsertWithWhereUniqueWithoutReleaseInput | ReleaseProductUpsertWithWhereUniqueWithoutReleaseInput[]
    createMany?: ReleaseProductCreateManyReleaseInputEnvelope
    set?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
    disconnect?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
    delete?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
    connect?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
    update?: ReleaseProductUpdateWithWhereUniqueWithoutReleaseInput | ReleaseProductUpdateWithWhereUniqueWithoutReleaseInput[]
    updateMany?: ReleaseProductUpdateManyWithWhereWithoutReleaseInput | ReleaseProductUpdateManyWithWhereWithoutReleaseInput[]
    deleteMany?: ReleaseProductScalarWhereInput | ReleaseProductScalarWhereInput[]
  }

  export type ReleaseProductUncheckedUpdateManyWithoutReleaseNestedInput = {
    create?: XOR<ReleaseProductCreateWithoutReleaseInput, ReleaseProductUncheckedCreateWithoutReleaseInput> | ReleaseProductCreateWithoutReleaseInput[] | ReleaseProductUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseProductCreateOrConnectWithoutReleaseInput | ReleaseProductCreateOrConnectWithoutReleaseInput[]
    upsert?: ReleaseProductUpsertWithWhereUniqueWithoutReleaseInput | ReleaseProductUpsertWithWhereUniqueWithoutReleaseInput[]
    createMany?: ReleaseProductCreateManyReleaseInputEnvelope
    set?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
    disconnect?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
    delete?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
    connect?: ReleaseProductWhereUniqueInput | ReleaseProductWhereUniqueInput[]
    update?: ReleaseProductUpdateWithWhereUniqueWithoutReleaseInput | ReleaseProductUpdateWithWhereUniqueWithoutReleaseInput[]
    updateMany?: ReleaseProductUpdateManyWithWhereWithoutReleaseInput | ReleaseProductUpdateManyWithWhereWithoutReleaseInput[]
    deleteMany?: ReleaseProductScalarWhereInput | ReleaseProductScalarWhereInput[]
  }

  export type ReleaseCreateNestedOneWithoutProductsInput = {
    create?: XOR<ReleaseCreateWithoutProductsInput, ReleaseUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ReleaseCreateOrConnectWithoutProductsInput
    connect?: ReleaseWhereUniqueInput
  }

  export type ReleaseProductChangeCreateNestedManyWithoutReleaseProductInput = {
    create?: XOR<ReleaseProductChangeCreateWithoutReleaseProductInput, ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput> | ReleaseProductChangeCreateWithoutReleaseProductInput[] | ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput[]
    connectOrCreate?: ReleaseProductChangeCreateOrConnectWithoutReleaseProductInput | ReleaseProductChangeCreateOrConnectWithoutReleaseProductInput[]
    createMany?: ReleaseProductChangeCreateManyReleaseProductInputEnvelope
    connect?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
  }

  export type ReleaseProductChangeUncheckedCreateNestedManyWithoutReleaseProductInput = {
    create?: XOR<ReleaseProductChangeCreateWithoutReleaseProductInput, ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput> | ReleaseProductChangeCreateWithoutReleaseProductInput[] | ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput[]
    connectOrCreate?: ReleaseProductChangeCreateOrConnectWithoutReleaseProductInput | ReleaseProductChangeCreateOrConnectWithoutReleaseProductInput[]
    createMany?: ReleaseProductChangeCreateManyReleaseProductInputEnvelope
    connect?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
  }

  export type NullableEnumSourceTierFieldUpdateOperationsInput = {
    set?: $Enums.SourceTier | null
  }

  export type EnumConfidenceFieldUpdateOperationsInput = {
    set?: $Enums.Confidence
  }

  export type ReleaseUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ReleaseCreateWithoutProductsInput, ReleaseUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ReleaseCreateOrConnectWithoutProductsInput
    upsert?: ReleaseUpsertWithoutProductsInput
    connect?: ReleaseWhereUniqueInput
    update?: XOR<XOR<ReleaseUpdateToOneWithWhereWithoutProductsInput, ReleaseUpdateWithoutProductsInput>, ReleaseUncheckedUpdateWithoutProductsInput>
  }

  export type ReleaseProductChangeUpdateManyWithoutReleaseProductNestedInput = {
    create?: XOR<ReleaseProductChangeCreateWithoutReleaseProductInput, ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput> | ReleaseProductChangeCreateWithoutReleaseProductInput[] | ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput[]
    connectOrCreate?: ReleaseProductChangeCreateOrConnectWithoutReleaseProductInput | ReleaseProductChangeCreateOrConnectWithoutReleaseProductInput[]
    upsert?: ReleaseProductChangeUpsertWithWhereUniqueWithoutReleaseProductInput | ReleaseProductChangeUpsertWithWhereUniqueWithoutReleaseProductInput[]
    createMany?: ReleaseProductChangeCreateManyReleaseProductInputEnvelope
    set?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
    disconnect?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
    delete?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
    connect?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
    update?: ReleaseProductChangeUpdateWithWhereUniqueWithoutReleaseProductInput | ReleaseProductChangeUpdateWithWhereUniqueWithoutReleaseProductInput[]
    updateMany?: ReleaseProductChangeUpdateManyWithWhereWithoutReleaseProductInput | ReleaseProductChangeUpdateManyWithWhereWithoutReleaseProductInput[]
    deleteMany?: ReleaseProductChangeScalarWhereInput | ReleaseProductChangeScalarWhereInput[]
  }

  export type ReleaseProductChangeUncheckedUpdateManyWithoutReleaseProductNestedInput = {
    create?: XOR<ReleaseProductChangeCreateWithoutReleaseProductInput, ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput> | ReleaseProductChangeCreateWithoutReleaseProductInput[] | ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput[]
    connectOrCreate?: ReleaseProductChangeCreateOrConnectWithoutReleaseProductInput | ReleaseProductChangeCreateOrConnectWithoutReleaseProductInput[]
    upsert?: ReleaseProductChangeUpsertWithWhereUniqueWithoutReleaseProductInput | ReleaseProductChangeUpsertWithWhereUniqueWithoutReleaseProductInput[]
    createMany?: ReleaseProductChangeCreateManyReleaseProductInputEnvelope
    set?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
    disconnect?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
    delete?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
    connect?: ReleaseProductChangeWhereUniqueInput | ReleaseProductChangeWhereUniqueInput[]
    update?: ReleaseProductChangeUpdateWithWhereUniqueWithoutReleaseProductInput | ReleaseProductChangeUpdateWithWhereUniqueWithoutReleaseProductInput[]
    updateMany?: ReleaseProductChangeUpdateManyWithWhereWithoutReleaseProductInput | ReleaseProductChangeUpdateManyWithWhereWithoutReleaseProductInput[]
    deleteMany?: ReleaseProductChangeScalarWhereInput | ReleaseProductChangeScalarWhereInput[]
  }

  export type ReleaseProductCreateNestedOneWithoutChangesInput = {
    create?: XOR<ReleaseProductCreateWithoutChangesInput, ReleaseProductUncheckedCreateWithoutChangesInput>
    connectOrCreate?: ReleaseProductCreateOrConnectWithoutChangesInput
    connect?: ReleaseProductWhereUniqueInput
  }

  export type ReleaseProductUpdateOneRequiredWithoutChangesNestedInput = {
    create?: XOR<ReleaseProductCreateWithoutChangesInput, ReleaseProductUncheckedCreateWithoutChangesInput>
    connectOrCreate?: ReleaseProductCreateOrConnectWithoutChangesInput
    upsert?: ReleaseProductUpsertWithoutChangesInput
    connect?: ReleaseProductWhereUniqueInput
    update?: XOR<XOR<ReleaseProductUpdateToOneWithWhereWithoutChangesInput, ReleaseProductUpdateWithoutChangesInput>, ReleaseProductUncheckedUpdateWithoutChangesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanFilter<$PrismaModel> | $Enums.Plan
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanWithAggregatesFilter<$PrismaModel> | $Enums.Plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanFilter<$PrismaModel>
    _max?: NestedEnumPlanFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type NestedEnumLiquidityFilter<$PrismaModel = never> = {
    equals?: $Enums.Liquidity | EnumLiquidityFieldRefInput<$PrismaModel>
    in?: $Enums.Liquidity[] | ListEnumLiquidityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Liquidity[] | ListEnumLiquidityFieldRefInput<$PrismaModel>
    not?: NestedEnumLiquidityFilter<$PrismaModel> | $Enums.Liquidity
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type NestedEnumLiquidityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Liquidity | EnumLiquidityFieldRefInput<$PrismaModel>
    in?: $Enums.Liquidity[] | ListEnumLiquidityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Liquidity[] | ListEnumLiquidityFieldRefInput<$PrismaModel>
    not?: NestedEnumLiquidityWithAggregatesFilter<$PrismaModel> | $Enums.Liquidity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLiquidityFilter<$PrismaModel>
    _max?: NestedEnumLiquidityFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSourceTierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceTier | EnumSourceTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.SourceTier[] | ListEnumSourceTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SourceTier[] | ListEnumSourceTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSourceTierNullableFilter<$PrismaModel> | $Enums.SourceTier | null
  }

  export type NestedEnumConfidenceFilter<$PrismaModel = never> = {
    equals?: $Enums.Confidence | EnumConfidenceFieldRefInput<$PrismaModel>
    in?: $Enums.Confidence[] | ListEnumConfidenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Confidence[] | ListEnumConfidenceFieldRefInput<$PrismaModel>
    not?: NestedEnumConfidenceFilter<$PrismaModel> | $Enums.Confidence
  }

  export type NestedEnumSourceTierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceTier | EnumSourceTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.SourceTier[] | ListEnumSourceTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SourceTier[] | ListEnumSourceTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSourceTierNullableWithAggregatesFilter<$PrismaModel> | $Enums.SourceTier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSourceTierNullableFilter<$PrismaModel>
    _max?: NestedEnumSourceTierNullableFilter<$PrismaModel>
  }

  export type NestedEnumConfidenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Confidence | EnumConfidenceFieldRefInput<$PrismaModel>
    in?: $Enums.Confidence[] | ListEnumConfidenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Confidence[] | ListEnumConfidenceFieldRefInput<$PrismaModel>
    not?: NestedEnumConfidenceWithAggregatesFilter<$PrismaModel> | $Enums.Confidence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfidenceFilter<$PrismaModel>
    _max?: NestedEnumConfidenceFilter<$PrismaModel>
  }

  export type UserPreferencesCreateWithoutUserInput = {
    id?: string
    categories?: UserPreferencesCreatecategoriesInput | string[]
    priceRangeMin?: number
    priceRangeMax?: number
    grades?: UserPreferencesCreategradesInput | string[]
    graders?: UserPreferencesCreategradersInput | string[]
    dealAlertThreshold?: number
    notificationChannels?: UserPreferencesCreatenotificationChannelsInput | string[]
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    categories?: UserPreferencesCreatecategoriesInput | string[]
    priceRangeMin?: number
    priceRangeMax?: number
    grades?: UserPreferencesCreategradesInput | string[]
    graders?: UserPreferencesCreategradersInput | string[]
    dealAlertThreshold?: number
    notificationChannels?: UserPreferencesCreatenotificationChannelsInput | string[]
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type PortfolioItemCreateWithoutUserInput = {
    id?: string
    cardName: string
    cardSet: string
    year: number
    grade: string
    grader?: string | null
    currentValue: number
    purchasePrice: number
    purchaseDate?: Date | string
    quantity?: number
    imageUrl?: string | null
    notes?: string | null
    inGradingQueue?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioItemUncheckedCreateWithoutUserInput = {
    id?: string
    cardName: string
    cardSet: string
    year: number
    grade: string
    grader?: string | null
    currentValue: number
    purchasePrice: number
    purchaseDate?: Date | string
    quantity?: number
    imageUrl?: string | null
    notes?: string | null
    inGradingQueue?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioItemCreateOrConnectWithoutUserInput = {
    where: PortfolioItemWhereUniqueInput
    create: XOR<PortfolioItemCreateWithoutUserInput, PortfolioItemUncheckedCreateWithoutUserInput>
  }

  export type PortfolioItemCreateManyUserInputEnvelope = {
    data: PortfolioItemCreateManyUserInput | PortfolioItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TrackedDealCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    deal: DealCreateNestedOneWithoutTrackedByInput
  }

  export type TrackedDealUncheckedCreateWithoutUserInput = {
    id?: string
    dealId: string
    createdAt?: Date | string
  }

  export type TrackedDealCreateOrConnectWithoutUserInput = {
    where: TrackedDealWhereUniqueInput
    create: XOR<TrackedDealCreateWithoutUserInput, TrackedDealUncheckedCreateWithoutUserInput>
  }

  export type TrackedDealCreateManyUserInputEnvelope = {
    data: TrackedDealCreateManyUserInput | TrackedDealCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferencesUpsertWithoutUserInput = {
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categories?: UserPreferencesUpdatecategoriesInput | string[]
    priceRangeMin?: FloatFieldUpdateOperationsInput | number
    priceRangeMax?: FloatFieldUpdateOperationsInput | number
    grades?: UserPreferencesUpdategradesInput | string[]
    graders?: UserPreferencesUpdategradersInput | string[]
    dealAlertThreshold?: FloatFieldUpdateOperationsInput | number
    notificationChannels?: UserPreferencesUpdatenotificationChannelsInput | string[]
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categories?: UserPreferencesUpdatecategoriesInput | string[]
    priceRangeMin?: FloatFieldUpdateOperationsInput | number
    priceRangeMax?: FloatFieldUpdateOperationsInput | number
    grades?: UserPreferencesUpdategradesInput | string[]
    graders?: UserPreferencesUpdategradersInput | string[]
    dealAlertThreshold?: FloatFieldUpdateOperationsInput | number
    notificationChannels?: UserPreferencesUpdatenotificationChannelsInput | string[]
  }

  export type PortfolioItemUpsertWithWhereUniqueWithoutUserInput = {
    where: PortfolioItemWhereUniqueInput
    update: XOR<PortfolioItemUpdateWithoutUserInput, PortfolioItemUncheckedUpdateWithoutUserInput>
    create: XOR<PortfolioItemCreateWithoutUserInput, PortfolioItemUncheckedCreateWithoutUserInput>
  }

  export type PortfolioItemUpdateWithWhereUniqueWithoutUserInput = {
    where: PortfolioItemWhereUniqueInput
    data: XOR<PortfolioItemUpdateWithoutUserInput, PortfolioItemUncheckedUpdateWithoutUserInput>
  }

  export type PortfolioItemUpdateManyWithWhereWithoutUserInput = {
    where: PortfolioItemScalarWhereInput
    data: XOR<PortfolioItemUpdateManyMutationInput, PortfolioItemUncheckedUpdateManyWithoutUserInput>
  }

  export type PortfolioItemScalarWhereInput = {
    AND?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
    OR?: PortfolioItemScalarWhereInput[]
    NOT?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
    id?: StringFilter<"PortfolioItem"> | string
    userId?: StringFilter<"PortfolioItem"> | string
    cardName?: StringFilter<"PortfolioItem"> | string
    cardSet?: StringFilter<"PortfolioItem"> | string
    year?: IntFilter<"PortfolioItem"> | number
    grade?: StringFilter<"PortfolioItem"> | string
    grader?: StringNullableFilter<"PortfolioItem"> | string | null
    currentValue?: FloatFilter<"PortfolioItem"> | number
    purchasePrice?: FloatFilter<"PortfolioItem"> | number
    purchaseDate?: DateTimeFilter<"PortfolioItem"> | Date | string
    quantity?: IntFilter<"PortfolioItem"> | number
    imageUrl?: StringNullableFilter<"PortfolioItem"> | string | null
    notes?: StringNullableFilter<"PortfolioItem"> | string | null
    inGradingQueue?: BoolFilter<"PortfolioItem"> | boolean
    createdAt?: DateTimeFilter<"PortfolioItem"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioItem"> | Date | string
  }

  export type TrackedDealUpsertWithWhereUniqueWithoutUserInput = {
    where: TrackedDealWhereUniqueInput
    update: XOR<TrackedDealUpdateWithoutUserInput, TrackedDealUncheckedUpdateWithoutUserInput>
    create: XOR<TrackedDealCreateWithoutUserInput, TrackedDealUncheckedCreateWithoutUserInput>
  }

  export type TrackedDealUpdateWithWhereUniqueWithoutUserInput = {
    where: TrackedDealWhereUniqueInput
    data: XOR<TrackedDealUpdateWithoutUserInput, TrackedDealUncheckedUpdateWithoutUserInput>
  }

  export type TrackedDealUpdateManyWithWhereWithoutUserInput = {
    where: TrackedDealScalarWhereInput
    data: XOR<TrackedDealUpdateManyMutationInput, TrackedDealUncheckedUpdateManyWithoutUserInput>
  }

  export type TrackedDealScalarWhereInput = {
    AND?: TrackedDealScalarWhereInput | TrackedDealScalarWhereInput[]
    OR?: TrackedDealScalarWhereInput[]
    NOT?: TrackedDealScalarWhereInput | TrackedDealScalarWhereInput[]
    id?: StringFilter<"TrackedDeal"> | string
    userId?: StringFilter<"TrackedDeal"> | string
    dealId?: StringFilter<"TrackedDeal"> | string
    createdAt?: DateTimeFilter<"TrackedDeal"> | Date | string
  }

  export type UserCreateWithoutPreferencesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    plan?: $Enums.Plan
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioItemCreateNestedManyWithoutUserInput
    trackedDeals?: TrackedDealCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    plan?: $Enums.Plan
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutUserInput
    trackedDeals?: TrackedDealUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioItemUpdateManyWithoutUserNestedInput
    trackedDeals?: TrackedDealUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutUserNestedInput
    trackedDeals?: TrackedDealUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrackedDealCreateWithoutDealInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackedDealsInput
  }

  export type TrackedDealUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type TrackedDealCreateOrConnectWithoutDealInput = {
    where: TrackedDealWhereUniqueInput
    create: XOR<TrackedDealCreateWithoutDealInput, TrackedDealUncheckedCreateWithoutDealInput>
  }

  export type TrackedDealCreateManyDealInputEnvelope = {
    data: TrackedDealCreateManyDealInput | TrackedDealCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type TrackedDealUpsertWithWhereUniqueWithoutDealInput = {
    where: TrackedDealWhereUniqueInput
    update: XOR<TrackedDealUpdateWithoutDealInput, TrackedDealUncheckedUpdateWithoutDealInput>
    create: XOR<TrackedDealCreateWithoutDealInput, TrackedDealUncheckedCreateWithoutDealInput>
  }

  export type TrackedDealUpdateWithWhereUniqueWithoutDealInput = {
    where: TrackedDealWhereUniqueInput
    data: XOR<TrackedDealUpdateWithoutDealInput, TrackedDealUncheckedUpdateWithoutDealInput>
  }

  export type TrackedDealUpdateManyWithWhereWithoutDealInput = {
    where: TrackedDealScalarWhereInput
    data: XOR<TrackedDealUpdateManyMutationInput, TrackedDealUncheckedUpdateManyWithoutDealInput>
  }

  export type UserCreateWithoutTrackedDealsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    plan?: $Enums.Plan
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    portfolio?: PortfolioItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTrackedDealsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    plan?: $Enums.Plan
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTrackedDealsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrackedDealsInput, UserUncheckedCreateWithoutTrackedDealsInput>
  }

  export type DealCreateWithoutTrackedByInput = {
    id?: string
    cardName: string
    cardSet: string
    year: number
    cardNumber?: string | null
    variation?: string | null
    grade: string
    grader?: string | null
    marketPrice: number
    dealPrice: number
    savingsPercent: number
    savingsAmount: number
    marketplace: string
    sellerRating: number
    sellerFeedback: number
    listingUrl: string
    imageUrl?: string | null
    category: $Enums.Category
    liquidity: $Enums.Liquidity
    lastSoldPrice?: number | null
    thirtyDayAvg?: number | null
    ninetyDayTrend?: number | null
    popGraded?: number | null
    popGrade10?: number | null
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DealUncheckedCreateWithoutTrackedByInput = {
    id?: string
    cardName: string
    cardSet: string
    year: number
    cardNumber?: string | null
    variation?: string | null
    grade: string
    grader?: string | null
    marketPrice: number
    dealPrice: number
    savingsPercent: number
    savingsAmount: number
    marketplace: string
    sellerRating: number
    sellerFeedback: number
    listingUrl: string
    imageUrl?: string | null
    category: $Enums.Category
    liquidity: $Enums.Liquidity
    lastSoldPrice?: number | null
    thirtyDayAvg?: number | null
    ninetyDayTrend?: number | null
    popGraded?: number | null
    popGrade10?: number | null
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DealCreateOrConnectWithoutTrackedByInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutTrackedByInput, DealUncheckedCreateWithoutTrackedByInput>
  }

  export type UserUpsertWithoutTrackedDealsInput = {
    update: XOR<UserUpdateWithoutTrackedDealsInput, UserUncheckedUpdateWithoutTrackedDealsInput>
    create: XOR<UserCreateWithoutTrackedDealsInput, UserUncheckedCreateWithoutTrackedDealsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrackedDealsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrackedDealsInput, UserUncheckedUpdateWithoutTrackedDealsInput>
  }

  export type UserUpdateWithoutTrackedDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTrackedDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutTrackedByInput = {
    update: XOR<DealUpdateWithoutTrackedByInput, DealUncheckedUpdateWithoutTrackedByInput>
    create: XOR<DealCreateWithoutTrackedByInput, DealUncheckedCreateWithoutTrackedByInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutTrackedByInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutTrackedByInput, DealUncheckedUpdateWithoutTrackedByInput>
  }

  export type DealUpdateWithoutTrackedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    marketPrice?: FloatFieldUpdateOperationsInput | number
    dealPrice?: FloatFieldUpdateOperationsInput | number
    savingsPercent?: FloatFieldUpdateOperationsInput | number
    savingsAmount?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    sellerRating?: FloatFieldUpdateOperationsInput | number
    sellerFeedback?: IntFieldUpdateOperationsInput | number
    listingUrl?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    liquidity?: EnumLiquidityFieldUpdateOperationsInput | $Enums.Liquidity
    lastSoldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    thirtyDayAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ninetyDayTrend?: NullableFloatFieldUpdateOperationsInput | number | null
    popGraded?: NullableIntFieldUpdateOperationsInput | number | null
    popGrade10?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DealUncheckedUpdateWithoutTrackedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    marketPrice?: FloatFieldUpdateOperationsInput | number
    dealPrice?: FloatFieldUpdateOperationsInput | number
    savingsPercent?: FloatFieldUpdateOperationsInput | number
    savingsAmount?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    sellerRating?: FloatFieldUpdateOperationsInput | number
    sellerFeedback?: IntFieldUpdateOperationsInput | number
    listingUrl?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    liquidity?: EnumLiquidityFieldUpdateOperationsInput | $Enums.Liquidity
    lastSoldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    thirtyDayAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ninetyDayTrend?: NullableFloatFieldUpdateOperationsInput | number | null
    popGraded?: NullableIntFieldUpdateOperationsInput | number | null
    popGrade10?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserCreateWithoutPortfolioInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    plan?: $Enums.Plan
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    trackedDeals?: TrackedDealCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPortfolioInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    plan?: $Enums.Plan
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    trackedDeals?: TrackedDealUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPortfolioInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPortfolioInput, UserUncheckedCreateWithoutPortfolioInput>
  }

  export type UserUpsertWithoutPortfolioInput = {
    update: XOR<UserUpdateWithoutPortfolioInput, UserUncheckedUpdateWithoutPortfolioInput>
    create: XOR<UserCreateWithoutPortfolioInput, UserUncheckedCreateWithoutPortfolioInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPortfolioInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPortfolioInput, UserUncheckedUpdateWithoutPortfolioInput>
  }

  export type UserUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    trackedDeals?: TrackedDealUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    trackedDeals?: TrackedDealUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReleaseProductCreateWithoutReleaseInput = {
    id?: string
    name: string
    productType: string
    category: $Enums.Category
    msrp?: number | null
    estimatedResale?: number | null
    releaseDate?: Date | string | null
    preorderDate?: Date | string | null
    imageUrl?: string | null
    buyUrl?: string | null
    contentsSummary?: string | null
    sourceTier?: $Enums.SourceTier | null
    sourceUrl?: string | null
    confidence?: $Enums.Confidence
    createdAt?: Date | string
    updatedAt?: Date | string
    changes?: ReleaseProductChangeCreateNestedManyWithoutReleaseProductInput
  }

  export type ReleaseProductUncheckedCreateWithoutReleaseInput = {
    id?: string
    name: string
    productType: string
    category: $Enums.Category
    msrp?: number | null
    estimatedResale?: number | null
    releaseDate?: Date | string | null
    preorderDate?: Date | string | null
    imageUrl?: string | null
    buyUrl?: string | null
    contentsSummary?: string | null
    sourceTier?: $Enums.SourceTier | null
    sourceUrl?: string | null
    confidence?: $Enums.Confidence
    createdAt?: Date | string
    updatedAt?: Date | string
    changes?: ReleaseProductChangeUncheckedCreateNestedManyWithoutReleaseProductInput
  }

  export type ReleaseProductCreateOrConnectWithoutReleaseInput = {
    where: ReleaseProductWhereUniqueInput
    create: XOR<ReleaseProductCreateWithoutReleaseInput, ReleaseProductUncheckedCreateWithoutReleaseInput>
  }

  export type ReleaseProductCreateManyReleaseInputEnvelope = {
    data: ReleaseProductCreateManyReleaseInput | ReleaseProductCreateManyReleaseInput[]
    skipDuplicates?: boolean
  }

  export type ReleaseProductUpsertWithWhereUniqueWithoutReleaseInput = {
    where: ReleaseProductWhereUniqueInput
    update: XOR<ReleaseProductUpdateWithoutReleaseInput, ReleaseProductUncheckedUpdateWithoutReleaseInput>
    create: XOR<ReleaseProductCreateWithoutReleaseInput, ReleaseProductUncheckedCreateWithoutReleaseInput>
  }

  export type ReleaseProductUpdateWithWhereUniqueWithoutReleaseInput = {
    where: ReleaseProductWhereUniqueInput
    data: XOR<ReleaseProductUpdateWithoutReleaseInput, ReleaseProductUncheckedUpdateWithoutReleaseInput>
  }

  export type ReleaseProductUpdateManyWithWhereWithoutReleaseInput = {
    where: ReleaseProductScalarWhereInput
    data: XOR<ReleaseProductUpdateManyMutationInput, ReleaseProductUncheckedUpdateManyWithoutReleaseInput>
  }

  export type ReleaseProductScalarWhereInput = {
    AND?: ReleaseProductScalarWhereInput | ReleaseProductScalarWhereInput[]
    OR?: ReleaseProductScalarWhereInput[]
    NOT?: ReleaseProductScalarWhereInput | ReleaseProductScalarWhereInput[]
    id?: StringFilter<"ReleaseProduct"> | string
    releaseId?: StringFilter<"ReleaseProduct"> | string
    name?: StringFilter<"ReleaseProduct"> | string
    productType?: StringFilter<"ReleaseProduct"> | string
    category?: EnumCategoryFilter<"ReleaseProduct"> | $Enums.Category
    msrp?: FloatNullableFilter<"ReleaseProduct"> | number | null
    estimatedResale?: FloatNullableFilter<"ReleaseProduct"> | number | null
    releaseDate?: DateTimeNullableFilter<"ReleaseProduct"> | Date | string | null
    preorderDate?: DateTimeNullableFilter<"ReleaseProduct"> | Date | string | null
    imageUrl?: StringNullableFilter<"ReleaseProduct"> | string | null
    buyUrl?: StringNullableFilter<"ReleaseProduct"> | string | null
    contentsSummary?: StringNullableFilter<"ReleaseProduct"> | string | null
    sourceTier?: EnumSourceTierNullableFilter<"ReleaseProduct"> | $Enums.SourceTier | null
    sourceUrl?: StringNullableFilter<"ReleaseProduct"> | string | null
    confidence?: EnumConfidenceFilter<"ReleaseProduct"> | $Enums.Confidence
    createdAt?: DateTimeFilter<"ReleaseProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ReleaseProduct"> | Date | string
  }

  export type ReleaseCreateWithoutProductsInput = {
    id?: string
    name: string
    releaseDate: Date | string
    category: $Enums.Category
    manufacturer: string
    msrp: number
    estimatedResale?: number | null
    hypeScore?: number | null
    imageUrl?: string | null
    topChases?: ReleaseCreatetopChasesInput | string[]
    printRun?: string | null
    description?: string | null
    isReleased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    releaseDate: Date | string
    category: $Enums.Category
    manufacturer: string
    msrp: number
    estimatedResale?: number | null
    hypeScore?: number | null
    imageUrl?: string | null
    topChases?: ReleaseCreatetopChasesInput | string[]
    printRun?: string | null
    description?: string | null
    isReleased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseCreateOrConnectWithoutProductsInput = {
    where: ReleaseWhereUniqueInput
    create: XOR<ReleaseCreateWithoutProductsInput, ReleaseUncheckedCreateWithoutProductsInput>
  }

  export type ReleaseProductChangeCreateWithoutReleaseProductInput = {
    id?: string
    field: string
    oldValue?: string | null
    newValue?: string | null
    detectedAt?: Date | string
    sourceUrl?: string | null
  }

  export type ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput = {
    id?: string
    field: string
    oldValue?: string | null
    newValue?: string | null
    detectedAt?: Date | string
    sourceUrl?: string | null
  }

  export type ReleaseProductChangeCreateOrConnectWithoutReleaseProductInput = {
    where: ReleaseProductChangeWhereUniqueInput
    create: XOR<ReleaseProductChangeCreateWithoutReleaseProductInput, ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput>
  }

  export type ReleaseProductChangeCreateManyReleaseProductInputEnvelope = {
    data: ReleaseProductChangeCreateManyReleaseProductInput | ReleaseProductChangeCreateManyReleaseProductInput[]
    skipDuplicates?: boolean
  }

  export type ReleaseUpsertWithoutProductsInput = {
    update: XOR<ReleaseUpdateWithoutProductsInput, ReleaseUncheckedUpdateWithoutProductsInput>
    create: XOR<ReleaseCreateWithoutProductsInput, ReleaseUncheckedCreateWithoutProductsInput>
    where?: ReleaseWhereInput
  }

  export type ReleaseUpdateToOneWithWhereWithoutProductsInput = {
    where?: ReleaseWhereInput
    data: XOR<ReleaseUpdateWithoutProductsInput, ReleaseUncheckedUpdateWithoutProductsInput>
  }

  export type ReleaseUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    manufacturer?: StringFieldUpdateOperationsInput | string
    msrp?: FloatFieldUpdateOperationsInput | number
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    hypeScore?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topChases?: ReleaseUpdatetopChasesInput | string[]
    printRun?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isReleased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    manufacturer?: StringFieldUpdateOperationsInput | string
    msrp?: FloatFieldUpdateOperationsInput | number
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    hypeScore?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topChases?: ReleaseUpdatetopChasesInput | string[]
    printRun?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isReleased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseProductChangeUpsertWithWhereUniqueWithoutReleaseProductInput = {
    where: ReleaseProductChangeWhereUniqueInput
    update: XOR<ReleaseProductChangeUpdateWithoutReleaseProductInput, ReleaseProductChangeUncheckedUpdateWithoutReleaseProductInput>
    create: XOR<ReleaseProductChangeCreateWithoutReleaseProductInput, ReleaseProductChangeUncheckedCreateWithoutReleaseProductInput>
  }

  export type ReleaseProductChangeUpdateWithWhereUniqueWithoutReleaseProductInput = {
    where: ReleaseProductChangeWhereUniqueInput
    data: XOR<ReleaseProductChangeUpdateWithoutReleaseProductInput, ReleaseProductChangeUncheckedUpdateWithoutReleaseProductInput>
  }

  export type ReleaseProductChangeUpdateManyWithWhereWithoutReleaseProductInput = {
    where: ReleaseProductChangeScalarWhereInput
    data: XOR<ReleaseProductChangeUpdateManyMutationInput, ReleaseProductChangeUncheckedUpdateManyWithoutReleaseProductInput>
  }

  export type ReleaseProductChangeScalarWhereInput = {
    AND?: ReleaseProductChangeScalarWhereInput | ReleaseProductChangeScalarWhereInput[]
    OR?: ReleaseProductChangeScalarWhereInput[]
    NOT?: ReleaseProductChangeScalarWhereInput | ReleaseProductChangeScalarWhereInput[]
    id?: StringFilter<"ReleaseProductChange"> | string
    releaseProductId?: StringFilter<"ReleaseProductChange"> | string
    field?: StringFilter<"ReleaseProductChange"> | string
    oldValue?: StringNullableFilter<"ReleaseProductChange"> | string | null
    newValue?: StringNullableFilter<"ReleaseProductChange"> | string | null
    detectedAt?: DateTimeFilter<"ReleaseProductChange"> | Date | string
    sourceUrl?: StringNullableFilter<"ReleaseProductChange"> | string | null
  }

  export type ReleaseProductCreateWithoutChangesInput = {
    id?: string
    name: string
    productType: string
    category: $Enums.Category
    msrp?: number | null
    estimatedResale?: number | null
    releaseDate?: Date | string | null
    preorderDate?: Date | string | null
    imageUrl?: string | null
    buyUrl?: string | null
    contentsSummary?: string | null
    sourceTier?: $Enums.SourceTier | null
    sourceUrl?: string | null
    confidence?: $Enums.Confidence
    createdAt?: Date | string
    updatedAt?: Date | string
    release: ReleaseCreateNestedOneWithoutProductsInput
  }

  export type ReleaseProductUncheckedCreateWithoutChangesInput = {
    id?: string
    releaseId: string
    name: string
    productType: string
    category: $Enums.Category
    msrp?: number | null
    estimatedResale?: number | null
    releaseDate?: Date | string | null
    preorderDate?: Date | string | null
    imageUrl?: string | null
    buyUrl?: string | null
    contentsSummary?: string | null
    sourceTier?: $Enums.SourceTier | null
    sourceUrl?: string | null
    confidence?: $Enums.Confidence
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseProductCreateOrConnectWithoutChangesInput = {
    where: ReleaseProductWhereUniqueInput
    create: XOR<ReleaseProductCreateWithoutChangesInput, ReleaseProductUncheckedCreateWithoutChangesInput>
  }

  export type ReleaseProductUpsertWithoutChangesInput = {
    update: XOR<ReleaseProductUpdateWithoutChangesInput, ReleaseProductUncheckedUpdateWithoutChangesInput>
    create: XOR<ReleaseProductCreateWithoutChangesInput, ReleaseProductUncheckedCreateWithoutChangesInput>
    where?: ReleaseProductWhereInput
  }

  export type ReleaseProductUpdateToOneWithWhereWithoutChangesInput = {
    where?: ReleaseProductWhereInput
    data: XOR<ReleaseProductUpdateWithoutChangesInput, ReleaseProductUncheckedUpdateWithoutChangesInput>
  }

  export type ReleaseProductUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    msrp?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preorderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contentsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTier?: NullableEnumSourceTierFieldUpdateOperationsInput | $Enums.SourceTier | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: EnumConfidenceFieldUpdateOperationsInput | $Enums.Confidence
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    release?: ReleaseUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ReleaseProductUncheckedUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    msrp?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preorderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contentsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTier?: NullableEnumSourceTierFieldUpdateOperationsInput | $Enums.SourceTier | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: EnumConfidenceFieldUpdateOperationsInput | $Enums.Confidence
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemCreateManyUserInput = {
    id?: string
    cardName: string
    cardSet: string
    year: number
    grade: string
    grader?: string | null
    currentValue: number
    purchasePrice: number
    purchaseDate?: Date | string
    quantity?: number
    imageUrl?: string | null
    notes?: string | null
    inGradingQueue?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrackedDealCreateManyUserInput = {
    id?: string
    dealId: string
    createdAt?: Date | string
  }

  export type PortfolioItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    inGradingQueue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    inGradingQueue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardName?: StringFieldUpdateOperationsInput | string
    cardSet?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    grader?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    inGradingQueue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackedDealUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneRequiredWithoutTrackedByNestedInput
  }

  export type TrackedDealUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackedDealUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackedDealCreateManyDealInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type TrackedDealUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackedDealsNestedInput
  }

  export type TrackedDealUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackedDealUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseProductCreateManyReleaseInput = {
    id?: string
    name: string
    productType: string
    category: $Enums.Category
    msrp?: number | null
    estimatedResale?: number | null
    releaseDate?: Date | string | null
    preorderDate?: Date | string | null
    imageUrl?: string | null
    buyUrl?: string | null
    contentsSummary?: string | null
    sourceTier?: $Enums.SourceTier | null
    sourceUrl?: string | null
    confidence?: $Enums.Confidence
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseProductUpdateWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    msrp?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preorderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contentsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTier?: NullableEnumSourceTierFieldUpdateOperationsInput | $Enums.SourceTier | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: EnumConfidenceFieldUpdateOperationsInput | $Enums.Confidence
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: ReleaseProductChangeUpdateManyWithoutReleaseProductNestedInput
  }

  export type ReleaseProductUncheckedUpdateWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    msrp?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preorderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contentsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTier?: NullableEnumSourceTierFieldUpdateOperationsInput | $Enums.SourceTier | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: EnumConfidenceFieldUpdateOperationsInput | $Enums.Confidence
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: ReleaseProductChangeUncheckedUpdateManyWithoutReleaseProductNestedInput
  }

  export type ReleaseProductUncheckedUpdateManyWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    msrp?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedResale?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preorderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contentsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTier?: NullableEnumSourceTierFieldUpdateOperationsInput | $Enums.SourceTier | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: EnumConfidenceFieldUpdateOperationsInput | $Enums.Confidence
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseProductChangeCreateManyReleaseProductInput = {
    id?: string
    field: string
    oldValue?: string | null
    newValue?: string | null
    detectedAt?: Date | string
    sourceUrl?: string | null
  }

  export type ReleaseProductChangeUpdateWithoutReleaseProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReleaseProductChangeUncheckedUpdateWithoutReleaseProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReleaseProductChangeUncheckedUpdateManyWithoutReleaseProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealCountOutputTypeDefaultArgs instead
     */
    export type DealCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReleaseCountOutputTypeDefaultArgs instead
     */
    export type ReleaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReleaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReleaseProductCountOutputTypeDefaultArgs instead
     */
    export type ReleaseProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReleaseProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserPreferencesDefaultArgs instead
     */
    export type UserPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserPreferencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealDefaultArgs instead
     */
    export type DealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrackedDealDefaultArgs instead
     */
    export type TrackedDealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrackedDealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortfolioItemDefaultArgs instead
     */
    export type PortfolioItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortfolioItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReleaseDefaultArgs instead
     */
    export type ReleaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReleaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReleaseProductDefaultArgs instead
     */
    export type ReleaseProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReleaseProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReleaseProductChangeDefaultArgs instead
     */
    export type ReleaseProductChangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReleaseProductChangeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrendingItemDefaultArgs instead
     */
    export type TrendingItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrendingItemDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}